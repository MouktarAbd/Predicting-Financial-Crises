{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Predicting Financial Crisis: Study A x Processing 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the Financial Crises dataset: characterize/describe the dataset and compare various classification models (e.g., Logistic regression, SVM, NN, classification trees/forests, ... ) in terms of their ability to correctly predict financial crises. Make sure to treat this as a real-time prediction problem: when predicting financial crises is a given year t, you can only use features from previous years t-s (with s>0), but no contemporaneous variables from the same year t. Compare the quality of your predictions using different criteria and validation methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import style\n",
    "import seaborn as sns\n",
    "sns.set_style('whitegrid')\n",
    "from sklearn.model_selection import train_test_split, cross_val_predict, TimeSeriesSplit\n",
    "from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, BaggingClassifier, AdaBoostClassifier, GradientBoostingClassifier\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis\n",
    "from sklearn.naive_bayes import GaussianNB\n",
    "from xgboost import XGBClassifier\n",
    "from sklearn.linear_model import SGDClassifier\n",
    "from sklearn import svm\n",
    "from sklearn.preprocessing import LabelEncoder, MinMaxScaler, StandardScaler\n",
    "from sklearn import preprocessing\n",
    "from sklearn.metrics import precision_score, recall_score, f1_score, r2_score, mean_squared_error, confusion_matrix\n",
    "from sklearn.metrics import precision_recall_curve, roc_curve, roc_auc_score, average_precision_score\n",
    "from math import sqrt\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.utils import resample\n",
    "from imblearn.over_sampling import SMOTE\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('FinancialCrises.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0    1867\n",
       "1      79\n",
       "Name: crisisST, dtype: int64"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df['crisisST'].value_counts()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = df[['year', 'country', 'loans1', 'cpi', 'crisisST']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "df1 = df.loc[df['country'] == 'DNK']\n",
    "df2 = df.loc[df['country'] == 'AUS']\n",
    "df3 = df.loc[df['country'] == 'JPN']\n",
    "df4 = df.loc[df['country'] == 'ESP']\n",
    "df5 = df.loc[df['country'] == 'GBR']\n",
    "df6 = df.loc[df['country'] == 'SWE']\n",
    "df7 = df.loc[df['country'] == 'FRA']\n",
    "df8 = df.loc[df['country'] == 'NOR']\n",
    "df9 = df.loc[df['country'] == 'USA']\n",
    "df10 = df.loc[df['country'] == 'ITA']\n",
    "df11 = df.loc[df['country'] == 'DEU']\n",
    "df12 = df.loc[df['country'] == 'CAN']\n",
    "df13 = df.loc[df['country'] == 'NLD']\n",
    "df14 = df.loc[df['country'] == 'CHE']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def df_process(df):\n",
    "    df = df.dropna()\n",
    "    df = df.sort_values(by=['country', 'year'])\n",
    "    df['credit_growth'] = np.log(df['loans1']).diff() - np.log(df['cpi']).diff()\n",
    "    df['CG_lag_1'] = df['credit_growth'].shift(1)\n",
    "    df['CG_lag_2'] = df['credit_growth'].shift(2)\n",
    "    df['CG_lag_3'] = df['credit_growth'].shift(3)\n",
    "    df['CG_lag_4'] = df['credit_growth'].shift(4)\n",
    "    df['CG_lag_5'] = df['credit_growth'].shift(5)\n",
    "    df = df[['year', 'country', 'crisisST', 'credit_growth', 'CG_lag_1', 'CG_lag_2', 'CG_lag_3', 'CG_lag_4', 'CG_lag_5']]\n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "df1 = df_process(df1)\n",
    "df2 = df_process(df2)\n",
    "df3 = df_process(df3)\n",
    "df4 = df_process(df4)\n",
    "df5 = df_process(df5)\n",
    "df6 = df_process(df6)\n",
    "df7 = df_process(df7)\n",
    "df8 = df_process(df8)\n",
    "df9 = df_process(df9)\n",
    "df10 = df_process(df10)\n",
    "df11 = df_process(df11)\n",
    "df12 = df_process(df12)\n",
    "df13 = df_process(df13)\n",
    "df14 = df_process(df14)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12, df13, df14])\n",
    "df = df.dropna()\n",
    "enc = LabelEncoder()\n",
    "df['country'] = enc.fit_transform(df['country'])\n",
    "df = df.sort_values(by=['year', 'country'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0     123\n",
       "1     133\n",
       "2      97\n",
       "3     107\n",
       "4     113\n",
       "5      97\n",
       "6     107\n",
       "7     117\n",
       "8     129\n",
       "9     102\n",
       "10    103\n",
       "11    127\n",
       "12    132\n",
       "13    100\n",
       "Name: country, dtype: int64"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df = df.sort_values(by=['year', 'country'])\n",
    "df['country'].value_counts().sort_index()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 3\n",
    "df = df.set_index(np.arange(len(df)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Logistic Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = LogisticRegression(max_iter = 200, solver = 'newton-cg')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7363031914893617\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6548223350253808\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6069958847736626\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6938829787234042\n",
      "Confusion_Matrix 1\n",
      "[[328  48]\n",
      " [ 12   8]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6852791878172588\n",
      "Confusion_Matrix 2\n",
      "[[278 116]\n",
      " [  1   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6504997060552616\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Random Forest Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = RandomForestClassifier(criterion = 'entropy', max_features = 'auto', min_samples_leaf = 2, min_samples_split = 2,\n",
    "                            n_estimators = 500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6574468085106383\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7525380710659898\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.634185773074662\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6877659574468086\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.699238578680203\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6702674897119341\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average precision-recall score: 0.13\n"
     ]
    },
    {
     "data": {
      "image/png": "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SdKW755l/ey4dc/YG46ir6+PU089lYsvvpju7m5e97rX8fa3v525c+dOUJXtb7KndEqSJEnSmJYs6+dx2278vXv9/f088MAD7LLLLsycOZNFixZx+umnc8IJJ/DYxz62CZW2NwOfJEmSpLZzz7J+/tdu4x+Ju++++zjnnHM4++yzWbBgAd///vfZbbfduPPOO5k6dfOnhW6pDHySJEmS2sqqR9aybPWacU3pvPnmm/nkJz/Jl7/8ZQYGBjj88MM55ZRT/rK+k8MeGPgkSZIktZkl9RM6d9pA4BscHGRwcJApU6Zw4YUX8tWvfpVjjjmGk08+mfnz509mqW2vWW8wlCRJkqRNMhT4ho/wrV69ms9//vPsueeefOMb3wDgrW99K3fddRfnnHOOYW8EjvBJkiRJaitD7+Dbeevq3XhLlizhs5/9LOeeey73338/++67L1tvvTUAc+bMaVmdWwIDnyRJkqS2smT5X4/wvfCFL+SGG27gyCOP5B3veAeHHHIIXV1drSxxi2HgkyRJktQ21q9fz9XXL2bq2gHWDqyG6Vvxmc98hh122IE99tij1eVtcbyHT5IkSVLLPfzww5xzzjn09vZy6eXXsHb5n7nlllsAOPjggw17m8gRPkmSJEktdc899/C0pz2NpUuXsmDBArbbawFPefwOPOMZz2h1aVs8R/gkSZIkTbprr72W888/H4CddtqJE088kcsvv5xrrrmGgSkz2Xnbx7S4wjI4widJkiRpUqxbt46LLrqIs846i1/84hdsv/32HH300fT09PChD30IgP4163jg4UfYac7YL13X2BzhkyRJktR0P//5z4kIXvrSl3L77bfziU98gt/97nf09Px1sLtv+QDw6HfwadP8f/buPF7HOvH/+OssnEOWUFQcuy5rlIwlaUoptJCkVFpNUuFoylQz054WnYOslZS0ahFRmkrTJDUj1VS4QhRZIku2c3DO/fuD6ec7Uzl07nOd5fV8PHq47/u67+t+08ftfp/P57ouZ/gkSZIkxcWKFSvIysqiQYMGHHXUUVSrVo2hQ4fSvXt3kpN/voqs3rwDgCP3XoNPv40zfJIkSZLy1T//+U8uvPBC6tSpw0033QRAgwYNmDNnDj179vzFsgf/ew0+/TYWPkmSJEn54vXXX6d9+/a0bt2amTNnMmjQIIYPH35A+1i92cKXn1zSKUmS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y0hPTyctLY0bbriB119/HYBKlSpx/fXXW/YkSVKJ5gyfpCJryJAhDBs2jMTERHr16kV6ejotW7aMOpYkSVKh4QyfpCJj165dPP/882zZsgWAFi1acNNNN7F8+XImT55s2ZMkSfovFj5Jhd7GjRt54IEHqFu3LhdccAHPP/88ABdeeCFDhw6levXqESeUJEkqnFzSKanQ2rVrF4MHD2bixIls27aNk08+mbFjx9KlS5eoo0mSJBUJzvBJKlRisRhfffUVAKVKlWLRokWcd955fPLJJ7zzzjuceeaZJCb60SVJkpQXzvBJKhR27tzJCy+8QGZmJl988QXffPMNRxxxBLNmzbLgSZIkHSS/RUmK1KZNmxg6dCh16tThkksuYceOHTz88MNUrFgRwLInSZL0GzjDJykSu3btolSpUmzYsIE///nPdOzYkQkTJtCpUydLniRJUj6x8EXg4282Mv7vS8mN5e9+v/p+C42OqJC/O5XyUSwWY/bs2WRkZJCUlMSrr75K3bp1Wb58OWlpaVHHkyRJKnYsfBF444vV/G3h2nwvZ0dVLMOpjavl6z6l/JCdnc2zzz5LZmYm//73vzn8hadxQAAAGOZJREFU8MO57rrriMViJCQkWPYkSZLixMIXkTKlkpg58MSoY0gFYsSIEQwZMoSmTZsyYcIEevfuTWpqatSxJEmSij0Ln6R8t2DBAoYPH06XLl3o1q0bV1xxBccddxwdO3YkISEh6niSJEklhoVPUr6IxWL87W9/IyMjg1mzZpGamkrDhg0BOOywwzj11FMjTihJklTyWPgk5Ytzzz2XqVOncsQRR3D33Xdz9dVXc9hhh0UdS5IkqUSz8Ek6KGvXruXRRx9l8ODBlC1blosvvpju3bvTq1cvUlJSoo4nSZIkLHySDtDnn39OZmYmTz/9NDt37uTYY4+la9eu9OjRI+pokiRJ+i8WPkl5snXrVrp3785bb71F2bJlueqqqxg4cCBHH3101NEkSZL0Cyx8kn7R9u3bmTdvHh06dKBcuXJUrFiR++67j759+1K5cuWo40mSJGk/LHyS/seqVasYPXo048aNY/v27axcuZIqVarw4osvRh1NkiRJByAx6gCSCo+vv/6aPn36ULt2bYYOHUqHDh148803nc2TJEkqopzhk0q43NxcNm3aROXKldm1axevvvoq11xzDQMGDKBe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\n",
      "text/plain": [
       "<Figure size 1080x1080 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "y_score = proba_sm[2]\n",
    "precision, recall, thresholds = precision_recall_curve(y_t[2], y_score)\n",
    "from sklearn.metrics import average_precision_score\n",
    "average_precision = average_precision_score(y_t[2], y_score)\n",
    "\n",
    "print('Average precision-recall score: {0:0.2f}'.format(\n",
    "      average_precision))\n",
    "from sklearn.utils.fixes import signature\n",
    "step_kwargs = ({'step': 'post'}\n",
    "               if 'step' in signature(plt.fill_between).parameters\n",
    "               else {})\n",
    "plt.figure(figsize=(15,15))\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.step(recall, precision, color='b', alpha=0.2,\n",
    "         where='post')\n",
    "plt.fill_between(recall, precision, alpha=0.2, color='b', **step_kwargs)\n",
    "\n",
    "plt.xlabel('Recall')\n",
    "plt.ylabel('Precision')\n",
    "plt.ylim([0.0, 1.05])\n",
    "plt.xlim([0.0, 1.0])\n",
    "plt.title('2-class Precision-Recall curve: AP={0:0.2f}'.format(\n",
    "          average_precision))\n",
    "plt.subplot(2,1,2)\n",
    "fpr, tpr, _ = roc_curve(y_t[2], y_score)\n",
    "auc_score = roc_auc_score(y_t[2], y_score)\n",
    "\n",
    "plt.plot([0, 1], [0, 1], 'k--')\n",
    "plt.plot(fpr, tpr)\n",
    "plt.xlabel('False positive rate')\n",
    "plt.ylabel('True positive rate')\n",
    "plt.title('ROC curve: AUC Score = {0:0.2f}'.format(\n",
    "          auc_score))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Extra-Trees Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = ExtraTreesClassifier(criterion = 'entropy', max_features = 'auto', min_samples_leaf = 2, min_samples_split = 2,\n",
    "                            n_estimators = 500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6316489361702128\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6738578680203046\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6042034097589654\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6809840425531914\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7157360406091371\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6175778953556732\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Decision Tree Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = DecisionTreeClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5364361702127659\n",
      "Confusion_Matrix 1\n",
      "[[347  29]\n",
      " [ 17   3]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4276649746192893\n",
      "Confusion_Matrix 2\n",
      "[[337  57]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5601063829787234\n",
      "Confusion_Matrix 1\n",
      "[[346  30]\n",
      " [ 16   4]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4936548223350254\n",
      "Confusion_Matrix 2\n",
      "[[389   5]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5198412698412699\n",
      "Confusion_Matrix 3\n",
      "[[372   6]\n",
      " [ 17   1]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### BaggingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = BaggingClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6123005319148935\n",
      "Confusion_Matrix 1\n",
      "[[374   2]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4181472081218274\n",
      "Confusion_Matrix 2\n",
      "[[393   1]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5390946502057613\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5305851063829786\n",
      "Confusion_Matrix 1\n",
      "[[374   2]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6040609137055838\n",
      "Confusion_Matrix 2\n",
      "[[392   2]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5458553791887125\n",
      "Confusion_Matrix 3\n",
      "[[376   2]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### AdaBoost Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = AdaBoostClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.636968085106383\n",
      "Confusion_Matrix 1\n",
      "[[370   6]\n",
      " [ 19   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.9441624365482233\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6604938271604938\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5507978723404255\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8578680203045684\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6271310993533216\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### GradientBoostingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = GradientBoostingClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6618351063829787\n",
      "Confusion_Matrix 1\n",
      "[[373   3]\n",
      " [ 19   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.883248730964467\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6158877131099353\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6760638297872339\n",
      "Confusion_Matrix 1\n",
      "[[372   4]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8350253807106599\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6378600823045267\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### XGBoost Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = XGBClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6575797872340425\n",
      "Confusion_Matrix 1\n",
      "[[375   1]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.9098984771573604\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5895061728395061\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6450797872340426\n",
      "Confusion_Matrix 1\n",
      "[[375   1]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8109137055837563\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6333039388594944\n",
      "Confusion_Matrix 3\n",
      "[[375   3]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### KNeighbors Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = KNeighborsClassifier(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5480053191489361\n",
      "Confusion_Matrix 1\n",
      "[[376   0]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4949238578680203\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.48544973544973546\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5449468085106383\n",
      "Confusion_Matrix 1\n",
      "[[366  10]\n",
      " [ 19   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4949238578680203\n",
      "Confusion_Matrix 2\n",
      "[[391   3]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5324074074074074\n",
      "Confusion_Matrix 3\n",
      "[[372   6]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Naive Bayes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = GaussianNB()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6537234042553192\n",
      "Confusion_Matrix 1\n",
      "[[347  29]\n",
      " [ 19   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.40609137055837563\n",
      "Confusion_Matrix 2\n",
      "[[ 24 370]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.38065843621399176\n",
      "Confusion_Matrix 3\n",
      "[[ 10 368]\n",
      " [  0  18]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6542553191489361\n",
      "Confusion_Matrix 1\n",
      "[[366  10]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.38959390862944165\n",
      "Confusion_Matrix 2\n",
      "[[ 28 366]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3606701940035274\n",
      "Confusion_Matrix 3\n",
      "[[ 15 363]\n",
      " [  0  18]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Linear Discriminant Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = LinearDiscriminantAnalysis()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6957446808510638\n",
      "Confusion_Matrix 1\n",
      "[[374   2]\n",
      " [ 18   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3210659898477157\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.46119929453262787\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6849734042553193\n",
      "Confusion_Matrix 1\n",
      "[[292  84]\n",
      " [ 12   8]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.38578680203045684\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4676660787771899\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Quadratic Discriminant Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = QuadraticDiscriminantAnalysis()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6824468085106383\n",
      "Confusion_Matrix 1\n",
      "[[365  11]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5571065989847716\n",
      "Confusion_Matrix 2\n",
      "[[ 36 358]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4645796590241035\n",
      "Confusion_Matrix 3\n",
      "[[ 38 340]\n",
      " [  3  15]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6809840425531916\n",
      "Confusion_Matrix 1\n",
      "[[371   5]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5139593908629442\n",
      "Confusion_Matrix 2\n",
      "[[ 48 346]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.43944738389182836\n",
      "Confusion_Matrix 3\n",
      "[[ 74 304]\n",
      " [  5  13]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### SVM Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = svm.SVC(decision_function_shape='ovo', probability=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.2928191489361702\n",
      "Confusion_Matrix 1\n",
      "[[375   1]\n",
      " [ 20   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.33629441624365486\n",
      "Confusion_Matrix 2\n",
      "[[394   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4873603762492651\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7788563829787234\n",
      "Confusion_Matrix 1\n",
      "[[365  11]\n",
      " [ 15   5]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4441624365482233\n",
      "Confusion_Matrix 2\n",
      "[[388   6]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49353321575543796\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### SGD Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = SGDClassifier(loss = 'log')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6873670212765957\n",
      "Confusion_Matrix 1\n",
      "[[325  51]\n",
      " [ 14   6]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3870558375634518\n",
      "Confusion_Matrix 2\n",
      "[[329  65]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6362433862433862\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6331117021276595\n",
      "Confusion_Matrix 1\n",
      "[[270 106]\n",
      " [ 11   9]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6345177664974619\n",
      "Confusion_Matrix 2\n",
      "[[164 230]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.73559670781893\n",
      "Confusion_Matrix 3\n",
      "[[378   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
