{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Predicting Financial Crisis: Study A x Processing 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the Financial Crises dataset: characterize/describe the dataset and compare various classification models (e.g., Logistic regression, SVM, NN, classification trees/forests, ... ) in terms of their ability to correctly predict financial crises. Make sure to treat this as a real-time prediction problem: when predicting financial crises is a given year t, you can only use features from previous years t-s (with s>0), but no contemporaneous variables from the same year t. Compare the quality of your predictions using different criteria and validation methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import style\n",
    "import seaborn as sns\n",
    "sns.set_style('whitegrid')\n",
    "from sklearn.model_selection import train_test_split, cross_val_predict, TimeSeriesSplit\n",
    "from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, BaggingClassifier, AdaBoostClassifier, GradientBoostingClassifier\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis\n",
    "from sklearn.naive_bayes import GaussianNB\n",
    "from xgboost import XGBClassifier\n",
    "from sklearn.linear_model import SGDClassifier\n",
    "from sklearn import svm\n",
    "from sklearn.preprocessing import LabelEncoder, MinMaxScaler, StandardScaler\n",
    "from sklearn import preprocessing\n",
    "from sklearn.metrics import precision_score, recall_score, f1_score, r2_score, mean_squared_error, confusion_matrix\n",
    "from sklearn.metrics import precision_recall_curve, roc_curve, roc_auc_score, average_precision_score\n",
    "from math import sqrt\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.utils import resample\n",
    "from imblearn.over_sampling import SMOTE\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('FinancialCrises.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = df[['year', 'country', 'loans1', 'cpi', 'crisisST']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "df1 = df.loc[df['country'] == 'DNK']\n",
    "df2 = df.loc[df['country'] == 'AUS']\n",
    "df3 = df.loc[df['country'] == 'JPN']\n",
    "df4 = df.loc[df['country'] == 'ESP']\n",
    "df5 = df.loc[df['country'] == 'GBR']\n",
    "df6 = df.loc[df['country'] == 'SWE']\n",
    "df7 = df.loc[df['country'] == 'FRA']\n",
    "df8 = df.loc[df['country'] == 'NOR']\n",
    "df9 = df.loc[df['country'] == 'USA']\n",
    "df10 = df.loc[df['country'] == 'ITA']\n",
    "df11 = df.loc[df['country'] == 'DEU']\n",
    "df12 = df.loc[df['country'] == 'CAN']\n",
    "df13 = df.loc[df['country'] == 'NLD']\n",
    "df14 = df.loc[df['country'] == 'CHE']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def df_process(df):\n",
    "    df['loans1'] = df['loans1'].fillna(method = 'ffill')\n",
    "    df['loans1'] = df['loans1'].fillna(method = 'bfill')\n",
    "    df['cpi'] = df['cpi'].fillna(method = 'ffill')\n",
    "    df['cpi'] = df['cpi'].fillna(method = 'bfill')\n",
    "    df = df.sort_values(by=['country', 'year'])\n",
    "    df['credit_growth'] = np.log(df['loans1']).diff() - np.log(df['cpi']).diff()\n",
    "    df['CG_lag_1'] = df['credit_growth'].shift(1)\n",
    "    df['CG_lag_2'] = df['credit_growth'].shift(2)\n",
    "    df['CG_lag_3'] = df['credit_growth'].shift(3)\n",
    "    df['CG_lag_4'] = df['credit_growth'].shift(4)\n",
    "    df['CG_lag_5'] = df['credit_growth'].shift(5)\n",
    "    df = df[['year', 'country', 'crisisST', 'credit_growth', 'CG_lag_1', 'CG_lag_2', 'CG_lag_3', 'CG_lag_4', 'CG_lag_5']]\n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "df1 = df_process(df1)\n",
    "df2 = df_process(df2)\n",
    "df3 = df_process(df3)\n",
    "df4 = df_process(df4)\n",
    "df5 = df_process(df5)\n",
    "df6 = df_process(df6)\n",
    "df7 = df_process(df7)\n",
    "df8 = df_process(df8)\n",
    "df9 = df_process(df9)\n",
    "df10 = df_process(df10)\n",
    "df11 = df_process(df11)\n",
    "df12 = df_process(df12)\n",
    "df13 = df_process(df13)\n",
    "df14 = df_process(df14)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8, df9, df10, df11, df12, df13, df14])\n",
    "df = df.dropna()\n",
    "enc = LabelEncoder()\n",
    "df['country'] = enc.fit_transform(df['country'])\n",
    "df = df.sort_values(by=['year', 'country'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 4\n",
    "df = df.set_index(np.arange(len(df)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Logistic Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = LogisticRegression(max_iter = 200, solver = 'newton-cg')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4975324675324675\n",
      "Confusion_Matrix 1\n",
      "[[348   2]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8013094938302694\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5635135135135135\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6370056497175142\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.45610389610389607\n",
      "Confusion_Matrix 1\n",
      "[[313  37]\n",
      " [ 20   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7967766305716444\n",
      "Confusion_Matrix 2\n",
      "[[339  22]\n",
      " [  9   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6148648648648649\n",
      "Confusion_Matrix 3\n",
      "[[358  12]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6679221594475832\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Random Forest Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = RandomForestClassifier(criterion = 'entropy', max_features = 'auto', min_samples_leaf = 2, min_samples_split = 2,\n",
    "                            n_estimators = 500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5412987012987013\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6272979098463864\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7695945945945946\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5612052730696798\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4825974025974026\n",
      "Confusion_Matrix 1\n",
      "[[341   9]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6600352556031226\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7283783783783784\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6538763339610797\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average precision-recall score: 0.13\n"
     ]
    },
    {
     "data": {
      "image/png": "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SdKW755l/ey4dc/YG46ir6+PU089lYsvvpju7m5e97rX8fa3v525c+dOUJXtb7KndEqSJEnSmJYs6+dx2278vXv9/f088MAD7LLLLsycOZNFixZx+umnc8IJJ/DYxz62CZW2NwOfJEmSpLZzz7J+/tdu4x+Ju++++zjnnHM4++yzWbBgAd///vfZbbfduPPOO5k6dfOnhW6pDHySJEmS2sqqR9aybPWacU3pvPnmm/nkJz/Jl7/8ZQYGBjj88MM55ZRT/rK+k8MeGPgkSZIktZkl9RM6d9pA4BscHGRwcJApU6Zw4YUX8tWvfpVjjjmGk08+mfnz509mqW2vWW8wlCRJkqRNMhT4ho/wrV69ms9//vPsueeefOMb3wDgrW99K3fddRfnnHOOYW8EjvBJkiRJaitD7+Dbeevq3XhLlizhs5/9LOeeey73338/++67L1tvvTUAc+bMaVmdWwIDnyRJkqS2smT5X4/wvfCFL+SGG27gyCOP5B3veAeHHHIIXV1drSxxi2HgkyRJktQ21q9fz9XXL2bq2gHWDqyG6Vvxmc98hh122IE99tij1eVtcbyHT5IkSVLLPfzww5xzzjn09vZy6eXXsHb5n7nlllsAOPjggw17m8gRPkmSJEktdc899/C0pz2NpUuXsmDBArbbawFPefwOPOMZz2h1aVs8R/gkSZIkTbprr72W888/H4CddtqJE088kcsvv5xrrrmGgSkz2Xnbx7S4wjI4widJkiRpUqxbt46LLrqIs846i1/84hdsv/32HH300fT09PChD30IgP4163jg4UfYac7YL13X2BzhkyRJktR0P//5z4kIXvrSl3L77bfziU98gt/97nf09Px1sLtv+QDw6HfwadP8f/buPF7HOvH/+OssnEOWUFQcuy5rlIwlaUoptJCkVFpNUuFoylQz054WnYOslZS0ahFRmkrTJDUj1VS4QhRZIku2c3DO/fuD6ec7Uzl07nOd5fV8PHq47/u67+t+08ftfp/P57ouZ/gkSZIkxcWKFSvIysqiQYMGHHXUUVSrVo2hQ4fSvXt3kpN/voqs3rwDgCP3XoNPv40zfJIkSZLy1T//+U8uvPBC6tSpw0033QRAgwYNmDNnDj179vzFsgf/ew0+/TYWPkmSJEn54vXXX6d9+/a0bt2amTNnMmjQIIYPH35A+1i92cKXn1zSKUmSJOmg/fjjjxxyyCEkJSXx0UcfsWrVKoYPH84VV1xB+fLlD3h/azZnUT41mXIpVpX84AyfJEmSpAO2fPlyBg8eTI0aNXj11VcBuOmmm1i8eDEDBw48qLIHe47hO9LZvXxjbZYkSZKUZ3PnziUjI4OXX36ZxMREevbsydFHHw1A2bK//dp5azZncYQnbMk3Fj5JkiRJeZKbm8sll1zCDz/8wI033sh1111HjRo18vU9Vm/OouERFfJ1nyWZhU+SJEnSz9q0aROPPfYYzz77LO+//z5lypTh5Zdfpm7dupQrVy7f329XTi7rtmZ7wpZ85DF8kiRJkv6PpUuXMmDAAGrUqMGNN95IhQoVWLt2LQDHHHNMXMoewPdbsonF8Bi+fOQMnyRJkqSfLFy4kCZNmpCcnMwFF1xAeno6xx57bIG895q9F113hi//WPgkSZKkEmzXrl1MmTKF1atXc8MNN9CwYUNGjBhBjx49OOqoowo0y6pNe67Bd6Qnbck3Fj5JkiQpDnJzY6zdkhV1jF+0adMmnn76aZ544gnWrFlD06bNuOCKfiQmJnJen6uAPZdIKEiLv98KOMOXnyx8kiRJUhzcNWMBE+csjzrGfjQi+dz7qQFsAk64/92I80D5lGQqpFpT8ot/kpIkSVIcfL8lm8PKpfDHTkdHHYUYEIYh5cuVo3r16qxavZpZs97gtFNPy/fLKvxW9auWIyEhIeoYxYaFT5IkSYqTimWSueB3NSN7/507d/Lcc8+RmZnJp59+yuWXX84Njz8O1GTwOa0jy6WC42UZJEmSpGLo4Ycfpnbt2lx66aXs3LmTxx57jDFjxkQdSwXMGT5JkiSpmAjDkAYNGpCYmMjq1as55phjeOKJJzjttNNcJllCOcMnSZIkFWGxWIy//e1vdOnShYYNGzJz5kwA7r77bt544w06depk2SvBLHySJElSEbRr1y4mTpxI8+bN6dSpE/Pnz+fOO++kdes9x+YlJvpVXy7plCRJkoqUnTt3Urp0aRISErjjjjuoWLEiEydO5MILLyQlJSXqeCpkLHySJElSEfDFF1+QmZnJ22+/TRiGpKSkMGfOHI466iiXbOoXOc8rSZIkFVKxWOyn4/CaNWvGs88+S+fOndm2bRsA1atXt+zpVznDJ0mSJBVSc+bMoXPnzhx55JHcc889XH311VSpUiXqWCpCLHySJElSIbFmzRpGjx5NUlISt99+OyeccAIvv/wyXbt2pXTp0lHHUxHkkk5JkiQpYp999hmXXXYZNWvW5J577mHJkiUAJCQk0L17d8ueDpqFT5IkSYrQAw88QIsWLZgyZQp/+MMfCMOQyZMnRx1LxYRLOiVJkqQCtG3bNp588klOOOEEmjdvTpcuXQDo27cvlSpVijidihsLnyRJklQAvvvuO0aNGsX48ePZuHEjt956K82bN6dp06Y0bdo06ngqpix8kiRJUpxdd911jB8/ntzcXLp160Z6ejonnHBC1LFUAlj4JEmSpHyWk5PDmtVrgLIAHH744Vx77bUMGDCAunXrRhtOJYqFT5IkSconW7duZeLEiYwYMYLNTXpQr+VJANx2220RJ1NJ5Vk6JUmSpN9oy5Yt3HTTTdSoUYMBAwZQtWpV2rVrxyGHlI06mko4C58kSZJ0kNatWwdASkoKL7zwAqeffjpz587lgw8+oEZaWsTpJJd0SpIkSQckJyeHqVOnkpGRwTfffMOyZcsoXbo0CxcupEyZMlHHk/4PZ/gkSZKkPPjxxx/JzMykfv36nHfeeaxevZobb7yRnJwcAMueCiVn+CRJkqRfEYvFSEhIYO7cuQwePJgTTzyRjIwMzj77bJKSkqKOJ/0qC58kSZL0M+bOnUtGRgb169dn6NChdOrUiU8++YQWLVpEHU3KM5d0SpIkSXvt3r2b559/njZt2tCuXTveeustypUrB0BCQoJlT0WOM3ySJEnSXunp6YwaNYr69eszatQoLr300p8Kn1QUOcMnSZKkEmvp0qUMHDiQzz//HIB+/foxbdo0wjDk2muvteypyHOGT5IkSSVKLBbj/fffJyMjg1dffZXk5GSaNWtGs2bNaNKkCU2aNIk6opRvLHySJEkqMWKxGB07dmT27NlUqVKFW265hf79+3PUUUdFHU2KCwufJEnar38u28C/lm/I8/O//34jVdcsiWMilWQHOr62b9/OF198QatWrUhISKDq7y+hz+lX0aJFC0qXLs0r4XYI83+8Llm7Nd/3KR0oC58kSdqvO1/7ki+++/EAX7UxLlmkPQ50fFXk729+tfd2VdgOf5+9LL9D/Y9TG1WN+3tIv8bCJ0mS9isnd88X1zEXtczT8xctWkTDhg3jnEol1f7G15o1q7mmf39mzphJ6dKl6d37Qq6/fgBNmzYtwJR7lEpKKPD3lPZl4ZMkSXmSkJBA6eS8neC7VFLenysdqJ8bX9nZ2Xz99dc0atSIaocfxorly7jtL7dyzTXXUK1atYiSStGz8EmSJKnIWr9+PePGjWP06NGkpKSwZMkSUlJS+Oyzz0hIcHZNikvhC4IgERgDNAeygavC8P8fCRsEwR+BC4Fc4N4wDF+JRw5JkiQVT0uWLOHBBx9k0qRJZGVlccYZZ5Cenk5SUhKAZU/aK14zfN2A1DAM2wZB0AZ4CDgHIAiCQ4EBQH3gEOBTwMInSZKkXxWLxcjOzgZg4cKFTJo0iT59+jBw4EAaN24ccTqpcIpX4WsPvAEQhuGHQRAcv8+2bcA37Cl7h7Bnlu9XZWdns3Dhwnjk/E2ysrIKZS4VD44vxZPjSwcqOyuLrVt253ncOMaUn7Kzs3nttdeYNGkSJ598Mv369aNu3bq8/fbbVKpUCcDxpnxT3D6/4lX4KgCb97mfEwRBchiGu/feXwEsAJKAofvbWUpKCo0aNcr/lL/RwoULC2UuFQ+OL8WT40sHKuXN9ZQrXybP48Yxpvywdu1axo4dy5gxY1i3bh3HHHMMp556KqmpqY4vxU1h/fz6+OOPD+p18Tp91o9A+X3fZ5+y1xk4EqgD1AS6BUHwuzjlkCRJUhE1aNAg7rjjDlq3bs3bb7/Np59+Ss+ePaOOJRUp8Sp8c4AuAHuP4ft8n20bgR1AdhiGWcAm4NA45ZAkSVIRkJuby+uvv06nTp1+Wk53xx13sGjRIqZPn84pp5ziiVikgxCvJZ2vAKcFQfABkABcHgTBYGBJGIbTgiA4FfgwCIJc4H3gb3HKIUmSpEJs+/btPPXUUwwfPpxFixZx1FFHsXz5cho1asTRRx8ddTypyItL4QvDMBfo918PL9pn+23AbfF4b0mSJBUNu3btolGjRnz77bccd9xxTJ48mZ49e1K6dOmoo0nFhhdelyRJUoH59NNPmTp1KrfddhulSpXiz3/+M0EQcOKJJ7pkU4oDC58kSZLiKjc3lxkzZpCZmcns2bM55JBDuOyyy6hduzZ9+/aNOp5UrMXrpC2SJEkSCxYsoGHDhpx99tksXryYBx54gBUrVlC7du2oo0klgjN8kiRJylffffcd33zzDe3ataNOnTrUq1ePO++8kx49elCqVKmo40klioVPkiRJ+WLevHlkZmbywgsvULduXRYtWkSZMmV4/fXXo44mlVgu6ZQkSdJv8t5779GhQwdatWrF9OnTuf7663njjTc8CYtUCDjDJ0mSpAO2ZcsWYrEYFSpUYP369Xz77bdkZGRw5ZVXUqFChajjSdrLGT5JkiTl2bfffsuNN95IWloaGRkZAJxzzjksWbKE9PR0y55UyDjDJ0mSpP366KOPyMjI4KWXXgLgvPPO48wzzwQgKSkpymiSfoWFT5IkST8rNzeXxMQ9C8KGDh3Ku+++S3p6Otdffz01a9aMOJ2kvLDwSZIk6f/YvHkzEyZMYPTo0bzxxhs0aNCAhx9+mEMPPZTy5ctHHU/SAbDwSZIkCYBly5YxcuRIJkyYwJYtWzjxxBPZunUrAGlpaRGnk3QwLHySJEliy5YtNG3alJ07d9KrVy/S09Np2bJl1LEk/UYWPkmSpBJo165dvPTSS/z9739n7NixlC9fnkmTJh7ieNsAACAASURBVNGmTRuqV68edTxJ+cTCJ0mSVIJs3LiRRx99lIcffpiVK1fSoEEDNmzYQOXKlenRo0fU8STlM6/DJ0mSVEK89957pKWlMWTIEBo0aMD06dNZtGgRlStXjjqapDhxhk+SJKmYisVivPfee2RnZ9OpUydatmzJRRddxDXXXEOLFi2ijiepAFj4JEmSipmdO3fywgsvkJmZyfz582nfvj2dOnXikEMOYfz48VHHk1SALHxShO5/YxGzvljzs9uyd+4kZcbaAk6kksLxpQO1cuMOalQqE3UM5cHkyZMZMmQIq1atolGjRowfP55LLrkk6liSImLhkyI0e9H3bN+ZQ6s6/3vsxI+bN1OhYsUIUqkkcHzpQDWpXpFzj/XMjYVVGIZUrVqVSpUqUapUKZo0acKECRPo1KkTiYmeskEqySx8UsSOqVGRhy889n8eX7hwIY0aNYogkUoCx5dU9MViMWbPnk1GRgYzZszg7rvv5tZbb6VXr1706tUr6niSCgl/5CNJklTETJo0iRYtWtCxY0f+9a9/cfvtt9O3b9+oY0kqhJzhkyRJKgK2bt1KuXLlAHj++efJzc1lwoQJ9O7dm9TU1IjTSSqsLHySJEmF2IIFCxg+fDjPPPMMn3/+OXXq1OHpp5+mYsWKJCQkRB1PUiFn4ZMkSSpkYrEYf/vb38jIyGDWrFmkpqbSp08fkpP3fHU79NBDI04oqaiw8EmSJBUya9eu5cwzz6RKlSrcfffdXH311Rx22GFRx5JUBFn4JEmSIrZ27VrGjBnDokWLeP755zniiCN45513aNWqFSkpKVHHk1SEeZZOSZKkiHz++edcccUV1KxZkzvvvJMdO3aQlZUFQPv27S17kn4zZ/gkSZIiMGXKFM4//3zKlCnDVVddxcCBAzn66KOjjiWpmLHwSZIkFYDt27fz1FNPccQRR3DOOedw+umnc99999G3b18qV64cdTxJxZRLOiVJkuJo1apV3HrrraSlpdGvXz9efPFFACpUqMCQIUMse5LiysInSZIUJ3fddRe1a9dm6NChdOjQgffee49JkyZFHUtSCWLhkyRJyie5ublMmzaNTZs2ARAEAf369WPx4sW88sornHjiiV4sXVKBsvBJkiT9Rtu2bWP06NE0bNiQc84556dZvPPPP5+RI0dSr169iBNKKqk8aYskSdJBys3N5dZbb2X8+PFs3LiR3/3udzz33HP06NEj6miSBFj4JEmSDtjy5cupXbs2iYmJzJ8/n44dO5Kenk7btm1dsimpULHwSZIk5UFOTg7Tpk0jIyODDz/8kK+//pq0tDRmzJhBcrJfqSQVTh7DJ0mS9Cu2bt3KyJEjOfroozn33HNZuXIlDz74IIceeiiAZU9SoeYnlCRJ0s/IyckhKSmJjRs3MnjwYNq0acMDDzzAOeecY8mTVGT4aSVJkrSPDz/8kMzMTLZu3cqMGTNIS0sjDEPPtCmpSHJJpyRJKvF2797NlClTaNeuHW3btmXWrFk0bdqU3NxcAMuepCLLGT5JklTijR07lgEDBlCvXj1GjhzJ5ZdfTrly5aKOJUm/mYVPkiSVOF9//TUjR46kffv2nHfeeVx88cWkpaVx1llnkZSUFHU8Sco3Fj5JklQixGIxPvjgAzIyMpg6dSqJiYlUrlwZgEqVKtGtW7eIE0pS/rPwSZKkEuHSSy/lqaeeolKlSgwZMoRrr72W6tWrRx1LkuLKwidJkoqljRs38thjj9GvXz/Kly9P9+7dadu2LX369OGQQw6JOp4kFQgLnyRJKlYWL17MiBEjmDhxItu3b6dWrVqcf/75dO/ePepoklTgLHySJKlYyMrK4oILLmDatGkkJyfTu3dvBg0aRIsWLaKOJkmRsfCpUFm2fhubtu+MOkaB2bErJ+oIklSk7dy5k3/961+ccMIJpKamkpyczK233kr//v058sgjo44nSZGz8KnQWPtjFicPezfqGAXu2LRDo44gSUXODz/8wPjx4xk1ahTr16/n22+/5YgjjuDFF1+MOpokFSoWPhUaW7N3A3D1SXVpU7dKxGkKTvMaFj5JyquVK1dyzz338OSTT7Jjxw5OO+00Bg8eTNWqVaOOJkmFkoVPhU7jIytwcuA/3JKkPWKxGD/++CMVK1Zk586dTJo06afj85o2bRp1PEkq1Cx8kiSpUMrOzubZZ58lMzOTtLQ0XnvtNerWrcuaNWsoX7581PEkqUhIjDqAJEnSvtatW8edd95JrVq1uPzyy8nNzaVHjx4/bbfsSVLeOcMnSZIKlfHjx3PbbbfRuXNnBg8eTMeOHUlISIg6liQVSc7wSZKkyMRiMd58803OOOMMpkyZAkD//v1ZsGABM2fO5NRTT7XsSdJv4AyfJEkqcFlZWUyePJnhw4fz5ZdfcsQRR5CVlQVA5cqVqVy5csQJJal4sPBJkqQC16lTJ/7xj3/QokULnnzySXr16kVKSkrUsSSp2MlT4QuCoAJQC/g6DMNt8Y0kSZKKm88//5yxY8fy4IMPcsghh3DLLbeQmprKSSed5JJNSYqj/Ra+IAjOA27d+9wXgiCIhWF4935ekwiMAZoD2cBVYRgu2Wd7Z+C2vXfnA9eGYRg7uN+CJEkqjHJzc3njjTfIyMjg7bffpmzZslxwwQV06NCBM844I+p4klQi5OWkLelAG2A9cDfQPQ+v6QakhmHYFvgT8NB/NgRBUB54EDgzDMM2wHLgsAOLLUmSCrNNmzbRuHFjunbtyqJFi7jvvvtYsWIFHTp0iDqaJJUoeSl8uWEYZgOxvbNweVnS2R54AyAMww+B4/fZ1g74HHgoCIJ/AGvDMFx3YLElSVJhs2rVKl555RUADj30UDp06MDTTz/NsmXLGDJkiCdikaQI5OUYvn8EQfAMUCMIgnHAv/LwmgrA5n3u5wRBkByG4W72zOadDLQAtu7d/9wwDL/6pZ1lZ2ezcOHCPLxtwcrKyiqUuYqqlZt3ArDqu1UsTPkx4jTRc3wpnhxfyk8LFixg0qRJzJw5k1KlSvHee++RlJREeno6AEuWLNnPHqQD42eY4qm4ja/9Fr4wDG8JguAM4BNgURiG0/Ow3x+B8vvcT9xb9gB+AP4VhuEagCAI3mNP+fvFwpeSkkKjRo3y8LYFa+HChYUyV1FVet1WYCVHVT+KRo2qRx0nco4vxZPjS/nhs88+Y9CgQbz77ruUK1eO/v37M2DAAOrVq+cYU1w5vhRPhXV8ffzxxwf1ul8sfEEQJAFJwHNAL+AdICkIgnfCMDxlP/udA5zFnpO8tGHPEs6fsgJNgyA4DNjEnuMDHz2o9JIkqUBt3bqVTZs2UaNGDcqUKcOyZcsYNmwYV155JYceemjU8SRJ/+XXZviuAG4BjgBCIAHIAd7Pw35fAU4LguCDva+7PAiCwcCSMAynBUFwMzBr73NfCMPwi4P9DUiSpPhbuXIlDz/8MI888ggnn3wyL7/8MkcffTRff/01iYl5OSWAJCkKv1j4wjB8FHg0CIIrwjB8/EB2GoZhLtDvvx5etM/259gzcyhJkgqx+fPnM2zYMKZMmUJubi49evT46dg8wLInSYVcXk7a8t7eGblS7JmtOyoMw6vjG0uSJEUlJyeHhIQEEhMTmTp1KjNmzGDAgAFcf/311K5dO+p4kqQDkJcfy03a+2t7oA5QJX5xJElSVLZs2cKIESNo0KAB06ZNA+CGG25gxYoVPPTQQ5Y9SSqC8lL4todhOBRYGYbhZUC1+EaSJEkF6ZtvvuGGG26gRo0aDBo0iKOOOopKlSoBULFiRSpUqBBxQknSwcrLks6EIAiOAMoFQXAI4FVTJUkqJmKxGJ06dWLp0qWcf/75pKen06pVq6hjSZLySV4K3x1AN2AysIz/v8RTkiQVMbt37+bll1/mySef5MUXX6RMmTI8/vjj1KxZk7S0tKjjSZLyWV4K3+/CMBy293bVeIaRJEnxsXnzZh577DFGjhzJt99+S7169Vi2bBmNGzfmhBNOiDqeJClO8nIMX5e9F2GXJElF0PLly6lRowZ//OMfqVOnDlOnTiUMQxo3bhx1NElSnOVlhu8wYFUQBMuAGBALw7BdfGNJkqSDFYvFmDNnDmEYcuWVV1KrVi0GDRpE9+7dOe6446KOJ0kqQHkpfGfFPYUkSfrNdu3axZQpU8jMzGTevHmkpaXRp08fSpUqxV133RV1PElSBPZb+MIw/KYggkiSpIM3a9YsrrzySr777juOPvpoxo4d+1PZkySVXHmZ4ZMkSYXQ4sWLAWjQoAFpaWkEQcD48ePp3LkziYl5OUxfklTc5flfgyAIKsUziCRJ2r9YLMa7777L2WefTRAE/PWvfwWgcePGvP3223Tt2tWyJ0n6yX5n+IIgOAkYDSQFQTAF+CYMwwlxT6ZCb1v2bka+s5jt2Tn5sr/NO3bly34kqbh68cUXueeee/j000857LDD+POf/0z//v2jjiVJKsTysqTzLqAD8BJwLzAHsPCJT1dsYvzfv6Z8ajKlkvLnp8lHVkylftVy+bIvSSoOfvjhBypVqkRiYiIff/wxO3fu5NFHH+Wiiy6iTJkyUceTJBVyeSl8uWEYbgiCIBaGYVYQBFvinkpFQiy259fHL2tFq9qVow0jScXMokWLGD58OJMmTWLKlCl07dqV2267jXvvvZeEhISo40mSioi8FL4lQRAMBaoEQfAnwLN2SpIUB7FYjLfffpuMjAxef/11UlJSuPjii2nQoAEAqampESeUJBU1eSl8/YCrgPeBbUDfuCaSJKmEicViJCQkkJOTw5VXXklWVhZ33HEH/fr1o2rVqlHHkyQVYXkpfFOAR4HxYRjG4pxHkqQS4/vvv2fs2LG88sorfPTRR6SkpDBz5kzq1avnbJ4kKV/k5Uwb9wBdgE+CILg9CIKacc4kSVKx9uWXX3LVVVdRs2ZNbr/9dqpXr84PP/wAQJMmTSx7kqR8s98ZvjAM5wHz9l6HbyywGEiJdzBJkoqj+fPn07JlS8qUKcPll1/OwIEDadiwYdSxJEnFVF6uw3cicBnQij3LO/8Y50ySJBUbO3bsYPLkyWzZsoXBgwdz7LHHMnbsWHr27EmVKlWijidJKubycgzfIOAR4CqP4ZMkKW/WrFnDmDFjGDt2LOvXr6dDhw6kp6eTkJBAv379oo4nSSohfvEYviAIjt978xEgBpwWBEGnIAg6FUgySZKKqAkTJlCrVi3uvvtu2rVrx+zZs3n33Xe9fp4kqcD92gxfR2AecMF/PR4D3oxbIkmSipjc3Fxef/116tSpQ+PGjTn++OPp27cvAwcO/OkaepIkReEXZ/jCMLx/7805YRhe/p//gE8LJpokSYXbtm3bGDt2LI0bN+bMM89kzJgxADRv3pxRo0ZZ9iRJkfvFGb4gCC4EzgZODoLglL0PJwLNgJEFkE2SpEJr6NChPPjgg2zcuJHjjz+eZ555hvPOOy/qWJIk/R+/tqTzDWA1UAUYv/exXGBpvENJklQY/fvf/6ZZs2YkJCSwadMmTj75ZNLT0znhhBM8Pk+SVCj9WuE7JAzDd4MgWPVfj5eLZyBJkgqTnJwcXnvtNTIyMnjvvfeYNWsWnTp14r777rPkSZIKvV8rfIP3/jf+vx6PAaf879MlSSo+srOzefTRRxk+fDhLly6lZs2aDBs2jNatWwNY9iRJRcIvFr4wDAfv/fXk/zwWBEFaGIYrCiKYJElRyMrKIjU1lYSEBIYOHUqtWrUYOnQo3bt3Jzk5L5evlSSp8Njvv1xBEAwAdgCHApcHQfDGf8qgJEnFxT//+U8yMzP58MMP+eqrryhdujTz58+nWrVqUUeTJOmg/eJlGfZxIfAk0BloArSIayJJkgpITk4OL730Eu3bt6d169bMnDmTHj16sGPHDgDLniSpyMvL2pQYcCSwNgzDWBAEleOcSZKkAjF79mzOO+886tSpw/Dhw7niiisoX7581LEkSco3eSl8s4H3gAuDIMgEXopvJEmS4mP58uWMHDmSSpUq8Ze//IWOHTsyY8YMTj/9dJKSkqKOJ0lSvtvvks4wDG8FagOLgZvCMLwr3qEkScpPc+fOpWfPntSrV4+HH36Y1atXA3vOtNmlSxfLniSp2Npv4QuC4Pfsudj634DFQRCcFu9QkiTll7/+9a+0a9eOt956ixtvvJFly5YxZsyYqGNJklQg8rKk826gfRiGq4IgqA68zJ7yJ0lSobNp0yYee+wxOnfuTJMmTTj33HOpVq0al156KeXKlYs6niRJBSovhS8nDMNVAGEYfhcEQVacM0mSdMCWLl3KyJEjefzxx9m6dSs5OTk0adKEFi1a0KKFJ5iWJJVMeSl8PwZBcD17TtzSAdgQ30iSJB2YPn36MHnyZJKTk7ngggtIT0/n2GOPjTqWJEmRy8t1+C4GarJnaWcacEVcE0mStB+7du1i2rRpxGIxAGrXrs3NN9/M8uXLmTRpkmVPkqS99jvDF4bh5iAIPgB+AL4Iw3Bj/GNJkvS/NmzYwCOPPMKoUaP47rvv+Mc//kH79u258847o44mSVKhlJezdD4G9AJ2AH32XotPkqQCs3HjRq699lrS0tK4+eabadiwITNmzKBdu3ZRR5MkqVDLyzF8zcIwbL339oggCD6MZyBJkgBisRhr1qzhyCOPpEyZMrz22mv06tWLQYMGccwxx0QdT5KkIiEvhW9JEAR1wjBcFgRBVeDbeIdSfHz8zQaufHIeO3fn5sv+dufuOXYmMSFfdidJAGRnZ/Pcc88xfPhwNm3axOLFi0lNTeWrr74iJSUl6niSJBUpeSl8bYCFQRB8C9QAsoMgWA3EwjA8Kq7plK+WrtvGpu27uKBVGuVT8/K/fv/KpZSiafWK+bIvSSXb+vXrGTduHKNHj2bNmjU0btyYW2+99acTs1j2JEk6cHk5aUu9ggiignPdKfWpUals1DEkCdizdDMhIYEPPviAv/zlL5x++uk8+eSTnHbaaSQkuIRAkqTfIn+meSRJOgCxWIy33nqLzMxMWrZsyV133cWZZ57JggULaNSoUdTxJEkqNvJyHT5JkvJFVlYWEydOpHnz5nTq1In58+dz2GGHAZCYmGjZkyQpn+Vphi8IggpALeDrMAy3xTeSJKm46t+/PxMnTqRZs2ZMnDiRCy+80GPzJEmKo7xch+884O/AM8DgIAj+HPdUkqRi4YsvvuDKK69k0aJFAKSnp/PWW2/x2Wefcdlll1n2JEmKs7ws6Uxnz5k61wN3A93jmkiSVKTFYjHeeOMNOnXqRLNmzXj22WeZP38+AM2aNaNjx46ejEWSpAKSl8KXG4ZhNnsuwxADXNIpSfpZubm5/O53v6Nz58588cUX3HvvvaxYsYLevXtHHU2SpBIpL4XvH0EQPAvUCIJgHPCvOGeSJBUhq1evZvTo0cRiMRITEzn//PN56qmnWL58OTfffDNVqlSJOqIkSSVWXq7Dd0sQBGcA84GFYRi+Fv9YkqTC7rPPPiMzM5NnnnmG3bt3c8opp9CoUSNuvPHGqKNJkqS98nLSlj5AVWAtUHnvfUlSCfXNN9/QsWNHWrRowYsvvsjVV1/NV1995SUVJEkqhPJyWYb//AueALQANgCT4pZIklTobNu2jWXLltG0aVMOP/xwNmzYwP3330/fvn2pVKlS1PEkSdIvyMuSzpv/czsIggTAJZ2SVEJ89913jBo1ivHjx1OlShXCMKRs2bLMnz/fM21KklQE7LfwBUFQep+7RwJ14hdHklQYfPnllwwdOpTnn3+e3NxcunfvTnp6+k8lz7InSVLRkJclnSEQY8+Szh3Ag3FNJEmKRE5ODjt37qRMmTIsWrSIV199leuuu44BAwZQp44/65MkqSjKS+H7SxiGkw9kp0EQJAJjgOZANnBVGIZLfuY5M4BXwzAcdyD7lyTln61btzJx4kRGjBjBJZdcwm233Ua3bt1YuXIlFStWjDqeJEn6DfJyHb6+B7HfbkBqGIZtgT8BD/3Mc+4GKh/EviVJ+eDbb7/lxhtvpEaNGgwYMIDDDz+cli1bApCUlGTZkySpGMjLDF9KEASfsGdpZy5AGIa99/Oa9sAbe5/7YRAEx++7MQiC8/bu6/UDTixJyhcDBw5k+vTp9OjRg/T0dNq0aRN1JEmSlM/yUviGHMR+KwCb97mfEwRBchiGu4MgaAr0Bs4D/pqXnWVnZ7Nw4cKDiBFfWVlZhTLXL1m9agsAS5YsYUu5UhGn0f4UtfGlwm337t28/fbbPPXUU9xzzz1Uq1aNP/zhD1x77bVUr14dwPGmfOVnmOLJ8aV4Km7j6xcLXxAEz4dh2CsMw78fxH5/BMrvcz8xDMPde2/3AaoD7wC1gZ1BECwPw/CNX9pZSkpKobyg78KFCwtlrl/y+bYVwDrq169PjUplo46j/Shq40uF048//siECRMYOXIky5cvp06dOqSmppKamkrnzp2jjqdizM8wxZPjS/FUWMfXxx9/fFCv+7UZvsMPLgoAc4CzgBeCIGgDfP6fDWEY3vSf20EQ3A6s+bWyJ0k6OFlZWdSvX59169bRvn17MjIyOPvss0lKSipWP7mUJEm/7NcKX70gCO79uQ1hGN6yn/2+ApwWBMEH7Lmcw+VBEAwGloRhOO3gokqSfk0sFmPu3Lm8/vrr3HXXXaSmpnLPPfdw7LHHcvzxx+9/B5Ikqdj5tcK3nT0najlgYRjmAv3+6+FFP/O82w9m/5Kk/2/37t289NJLZGRk8M9//pNDDz2U/v37c+SRR9K378GcaFmSJBUXv1b41oRh+GSBJZEkHbBPPvmEc845hxUrVlC/fn1GjRrFpZdeSrly5aKOJkmSCoFfK3wHd1SgJCmuli5dytq1a2nXrh0NGjSgefPmjB49mq5du5KYmJfLq0qSpJLiFwtfGIZ/LMggkqRfFovFeP/998nIyODVV1/lmGOO4dNPP6VcuXJMnz496niSJKmQ8kfBklTIvfnmm7Rq1YoOHTrw3nvvccsttzBz5syoY0mSpCIgLxdelyQVsA0bNpCcnEyFChX44Ycf2LZtG+PGjeOSSy6hbFmvoylJkvLGGT5JKkS++uorrr32WtLS0hg9ejQA559/Pl9++SVXX321ZU+SJB0QZ/iKke827eDzlZt+cfsX320uwDSSDsTs2bPJyMjgtddeo3Tp0lx00UWcddZZACQlJUWcTpIkFVUWvmLkTy/9m38sXv+rz0lKTKBciv/bpcIgJyfnpzL3wAMP8PHHH3PbbbdxzTXXUK1atYjTSZKk4sBv/sVI9q5cmteoyH09jvnF51QqW5pDy5YuwFSS/tv69esZN24c48eP5/3336dWrVo8+uijHHbYYaSmpkYdT5IkFSMWvmKmbOlkGh1ZIeoYkn7GwoULGT58OJMmTSIrK4szzjiD7du3A1CjRo2I00mSpOLIwidJBWDDhg20aNGCxMRELrnkEgYNGkTjxo2jjiVJkoo5C58kxUFWVhZPP/008+bNY+zYsVSuXJnnn3+eE044gcMPPzzqeJIkqYSw8ElSPlq7di1jx45lzJgxrFu3jmOOOYYtW7ZQvnx5unXrFnU8SZJUwlj4JCmfvPnmm5x99tlkZ2dz5plnkp6ezsknn0xCQkLU0SRJUgll4ZOkg5Sbm8usWbNITk7mtNNOo3Xr1vzhD3/g2muvJQiCqONJkiSRGHUASSpqduzYwSOPPEKTJk3o0qULw4YNA6BixYqMHDnSsidJkgoNC58kHYBHHnmEtLQ0rr76asqWLctTTz3F9OnTo44lSZL0s1zSKUn78emnn1KnTh0qVqxI2bJlad++PYMHD+bEE0/0+DxJklSoOcMnST8jNzeX6dOnc8opp3Dsscfy2GOPAXDxxRczdepUOnToYNmTJEmFnoVPkvYRi8UYM2YMDRs25Oyzz2bx4sU88MADXHHFFVFHkyRJOmAu6ZQkYPPmzVSsWJGEhARefvllKlWqxLPPPkuPHj0oVapU1PEkSZIOioVPUok2b948MjMzeeWVV1i8eDHVq1fn5Zdfpnz58i7ZlCRJRZ6FT1KJk5OTw7Rp08jMzOQf//gH5cuX5+qrryYpKQmAChUqRJxQkiQpf1j4JJU4q1atomfPntSoUYOMjAyuvPJKS54kSSqWLHySir1vv/2Whx9+mBUrVvDcc8+RlpbG+++/z/HHH09ysh+DkiSp+PIsnZKKrY8++ohevXpRt25dMjMzAdi1axcAbdq0sexJkqRiz287koqlJ554gssvv5yKFSuSnp7O9ddfT82aNaOOJUmSVKAsfJKKhc2bNzNhwgQaNGjAWWedxTnnnMPIkSO57LLLKF++fNTxJEmSIuGSTklF2rJly0hPTyctLY0bbriB119/HYBKlSpx/fXXW/YkSVKJ5gyfpCJryJAhDBs2jMTERHr16kV6ejotW7aMOpYkSVKh4QyfpCJj165dPP/882zZsgWAFi1acNNNN7F8+XImT55s2ZMkSfovFj5Jhd7GjRt54IEHqFu3LhdccAHPP/88ABdeeCFDhw6levXqESeUJEkqnFzSKanQ2rVrF4MHD2bixIls27aNk08+mbFjx9KlS5eoo0mSJBUJzvBJKlRisRhfffUVAKVKlWLRokWcd955fPLJJ7zzzjuceeaZJCb60SVJkpQXzvBJKhR27tzJCy+8QGZmJl988QXffPMNRxxxBLNmzbLgSZIkHSS/RUmK1KZNmxg6dCh16tThkksuYceOHTz88MNUrFgRwLInSZL0GzjDJykSu3btolSpUmzYsIE///nPdOzYkQkTJtCpUydLniRJUj6x8EXg4282Mv7vS8mN5e9+v/p+C42OqJC/O5XyUSwWY/bs2WRkZJCUlMSrr75K3bp1Wb58OWlpaVHHkyRJKnYsfBF444vV/G3h2nwvZ0dVLMOpjavl6z6l/JCdnc2zzz5LZmYm//73vzn8hadxQAAAGOZJREFU8MO57rrriMViJCQkWPYkSZLixMIXkTKlkpg58MSoY0gFYsSIEQwZMoSmTZsyYcIEevfuTWpqatSxJEmSij0Ln6R8t2DBAoYPH06XLl3o1q0bV1xxBccddxwdO3YkISEh6niSJEklhoVPUr6IxWL87W9/IyMjg1mzZpGamkrDhg0BOOywwzj11FMjTihJklTyWPgk5Ytzzz2XqVOncsQRR3D33Xdz9dVXc9hhh0UdS5IkqUSz8Ek6KGvXruXRRx9l8ODBlC1blosvvpju3bvTq1cvUlJSoo4nSZIkLHySDtDnn39OZmYmTz/9NDt37uTYY4+la9eu9OjRI+pokiRJ+i8WPkl5snXrVrp3785bb71F2bJlueqqqxg4cCBHH3101NEkSZL0Cyx8kn7R9u3bmTdvHh06dKBcuXJUrFiR++67j759+1K5cuWo40mSJGk/LHyS/seqVasYPXo048aNY/v27axcuZIqVarw4osvRh1NkiRJByAx6gCSCo+vv/6aPn36ULt2bYYOHUqHDh148803nc2TJEkqopzhk0q43NxcNm3aROXKldm1axevvvoq11xzDQMGDKBe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\n",
      "text/plain": [
       "<Figure size 1080x1080 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "y_score = proba_sm[2]\n",
    "precision, recall, thresholds = precision_recall_curve(y_t[2], y_score)\n",
    "from sklearn.metrics import average_precision_score\n",
    "average_precision = average_precision_score(y_t[2], y_score)\n",
    "\n",
    "print('Average precision-recall score: {0:0.2f}'.format(\n",
    "      average_precision))\n",
    "from sklearn.utils.fixes import signature\n",
    "step_kwargs = ({'step': 'post'}\n",
    "               if 'step' in signature(plt.fill_between).parameters\n",
    "               else {})\n",
    "plt.figure(figsize=(15,15))\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.step(recall, precision, color='b', alpha=0.2,\n",
    "         where='post')\n",
    "plt.fill_between(recall, precision, alpha=0.2, color='b', **step_kwargs)\n",
    "\n",
    "plt.xlabel('Recall')\n",
    "plt.ylabel('Precision')\n",
    "plt.ylim([0.0, 1.05])\n",
    "plt.xlim([0.0, 1.0])\n",
    "plt.title('2-class Precision-Recall curve: AP={0:0.2f}'.format(\n",
    "          average_precision))\n",
    "plt.subplot(2,1,2)\n",
    "fpr, tpr, _ = roc_curve(y_t[2], y_score)\n",
    "auc_score = roc_auc_score(y_t[2], y_score)\n",
    "\n",
    "plt.plot([0, 1], [0, 1], 'k--')\n",
    "plt.plot(fpr, tpr)\n",
    "plt.xlabel('False positive rate')\n",
    "plt.ylabel('True positive rate')\n",
    "plt.title('ROC curve: AUC Score = {0:0.2f}'.format(\n",
    "          auc_score))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Extra-Trees Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = ExtraTreesClassifier(criterion = 'entropy', max_features = 'auto', min_samples_leaf = 2, min_samples_split = 2,\n",
    "                            n_estimators = 500)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5368831168831169\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5391589020397884\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7256756756756757\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6197426239799121\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4836363636363637\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6280533870561572\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6459459459459459\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5790960451977402\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Decision Tree Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = DecisionTreeClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49558441558441557\n",
      "Confusion_Matrix 1\n",
      "[[331  19]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4845127171996978\n",
      "Confusion_Matrix 2\n",
      "[[317  44]\n",
      " [ 10   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49864864864864866\n",
      "Confusion_Matrix 3\n",
      "[[369   1]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.46285714285714286\n",
      "Confusion_Matrix 1\n",
      "[[324  26]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5410475950642155\n",
      "Confusion_Matrix 2\n",
      "[[325  36]\n",
      " [  9   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4929378531073446\n",
      "Confusion_Matrix 4\n",
      "[[349   5]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### BaggingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = BaggingClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5574025974025973\n",
      "Confusion_Matrix 1\n",
      "[[341   9]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5431881138252329\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4027027027027027\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5178123038292529\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5107792207792208\n",
      "Confusion_Matrix 1\n",
      "[[330  20]\n",
      " [ 20   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6203727020901536\n",
      "Confusion_Matrix 2\n",
      "[[357   4]\n",
      " [ 10   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49324324324324326\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5684243565599498\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### AdaBoost Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = AdaBoostClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.43201298701298707\n",
      "Confusion_Matrix 1\n",
      "[[336  14]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5460841097960212\n",
      "Confusion_Matrix 2\n",
      "[[356   5]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8094594594594594\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6741211550533586\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.45214285714285707\n",
      "Confusion_Matrix 1\n",
      "[[302  48]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6646940317300428\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.9216216216216215\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6178593848085374\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### GradientBoostingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = GradientBoostingClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5442857142857143\n",
      "Confusion_Matrix 1\n",
      "[[342   8]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6056408964996222\n",
      "Confusion_Matrix 2\n",
      "[[358   3]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8027027027027027\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.623587570621469\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4442857142857143\n",
      "Confusion_Matrix 1\n",
      "[[341   9]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.753210778141526\n",
      "Confusion_Matrix 2\n",
      "[[359   2]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.835135135135135\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6421060891399876\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### XGBoost Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = XGBClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5403896103896104\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5321077814152606\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8824324324324324\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5912586315128688\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.45974025974025967\n",
      "Confusion_Matrix 1\n",
      "[[329  21]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7620246789221858\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8783783783783784\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6628217200251099\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### KNeighbors Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = KNeighborsClassifier(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5215584415584416\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.595441954167716\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49864864864864866\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4887005649717514\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.530974025974026\n",
      "Confusion_Matrix 1\n",
      "[[281  69]\n",
      " [ 17   5]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6800554016620498\n",
      "Confusion_Matrix 2\n",
      "[[331  30]\n",
      " [  9   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49864864864864866\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4844632768361582\n",
      "Confusion_Matrix 4\n",
      "[[348   6]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Naive Bayes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = GaussianNB()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.45857142857142863\n",
      "Confusion_Matrix 1\n",
      "[[316  34]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7433895744145051\n",
      "Confusion_Matrix 2\n",
      "[[ 64 297]\n",
      " [  0  11]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.31756756756756754\n",
      "Confusion_Matrix 3\n",
      "[[  8 362]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3771186440677966\n",
      "Confusion_Matrix 4\n",
      "[[ 17 337]\n",
      " [  3  15]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5015584415584415\n",
      "Confusion_Matrix 1\n",
      "[[343   7]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7277763787459077\n",
      "Confusion_Matrix 2\n",
      "[[ 79 282]\n",
      " [  1  10]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3432432432432432\n",
      "Confusion_Matrix 3\n",
      "[[  9 361]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3639359698681732\n",
      "Confusion_Matrix 4\n",
      "[[ 23 331]\n",
      " [  3  15]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Linear Discriminant Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = LinearDiscriminantAnalysis()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4554545454545455\n",
      "Confusion_Matrix 1\n",
      "[[344   6]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6056408964996223\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.31351351351351353\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4891713747645951\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4325974025974026\n",
      "Confusion_Matrix 1\n",
      "[[296  54]\n",
      " [ 20   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6212540921682196\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.3202702702702703\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4918392969240426\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Quadratic Discriminant Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = QuadraticDiscriminantAnalysis()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.46532467532467536\n",
      "Confusion_Matrix 1\n",
      "[[346   4]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.775623268698061\n",
      "Confusion_Matrix 2\n",
      "[[120 241]\n",
      " [  1  10]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5297297297297296\n",
      "Confusion_Matrix 3\n",
      "[[ 21 349]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5569679849340866\n",
      "Confusion_Matrix 4\n",
      "[[131 223]\n",
      " [  3  15]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4794805194805195\n",
      "Confusion_Matrix 1\n",
      "[[348   2]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7386048854192899\n",
      "Confusion_Matrix 2\n",
      "[[158 203]\n",
      " [  2   9]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49189189189189186\n",
      "Confusion_Matrix 3\n",
      "[[ 39 331]\n",
      " [  0   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5872567482736974\n",
      "Confusion_Matrix 4\n",
      "[[169 185]\n",
      " [  7  11]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### SVM Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = svm.SVC(decision_function_shape='ovo', probability=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.525974025974026\n",
      "Confusion_Matrix 1\n",
      "[[350   0]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.17451523545706374\n",
      "Confusion_Matrix 2\n",
      "[[361   0]\n",
      " [ 11   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5270270270270271\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.4967043314500941\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.538051948051948\n",
      "Confusion_Matrix 1\n",
      "[[332  18]\n",
      " [ 20   2]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.8670360110803325\n",
      "Confusion_Matrix 2\n",
      "[[359   2]\n",
      " [ 10   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.41081081081081083\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.5004708097928436\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Average precision-recall score: 0.27\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA3wAAANoCAYAAACbU+ivAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4wLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvqOYd8AAAIABJREFUeJzs3Xt8XWWd9/1P2tATtGApchKnRZkfFRSQPnIU0FtReMABbmZEVBQHEfCEDIN466h4o44K4jgKDCKDqIxnHkURVDwgICqFKkr6wypFhCKn0hbapLTN88da0W1Ik7TNzk6u/Xm/Xnklex2u9Vs7V9p8c11rrY7e3l4kSZIkSeWZ0OoCJEmSJEnNYeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCdba6AElqdxHxGuBfgV5gJfC2zLx1A/Z/PzArM9/SnAohIn4M/B2wjKrOScCtwKmZuXIE2p8HnJ2Zxw6yzQeARZl5xaYer27v/cCbgfvqRR3ADOAq4F8yc0SfWxQRlwO/yczzIqIX2CYzHx7JYzRLRLwV+CSwX2be0rD8cuClwENU/WIz4PfAGzPzwSHa3Aa4gqpfrQNOzsybB9ju2cBFwDZU/e6zmXl+RLwEOK9h06nA3wPzMnP+Rp6qJBXHwCdJLRQRAXwMeH5mLomIw4FvAM9sbWUD+tfM/BpARHQAXwE+AJy5qQ3XAXe9Ya/e5r2bepwBfLkxKEfE04BfA9fVH6qcAnwROB04rt+6CzLzL8ErIs4HLmSI7yfwaeCnmXlYROwJfCcidhngDwiXA5dn5qURsSXwy4i4PTN/AOzZcNyvAd8w7EnS3zLwSVJr9QAnZeaS+vWtwHYRMSkzVzduGBGdwEeBI4A1wM3Aaf22OQL4P1QjIU8HPpeZ/xYRWwD/DexCNZoyH3gTMG2g5Zm5brCiM7M3In4EHF4ftwf4JrAH8GrgCeA/gK2BicAnM/Oyets3AP8CrAUeBl4HPAv4VGbuHhEHAh+v9+sFPpyZX+83QvZCqqA8DVgNvCczr42I1wNH1+eyC9WI6esys2uw82mwbd3m0rrWuRt4HvcBFwD7AtOpRg1PysybhnPwiNiHaiRt8/q8zszMH/YfEex7Dexe1/cEsAXwW+DWzDy/3u5U4JDMfGVEHAm8h6pvrKzb/llE7ABcAxyemfcPUNMhwEzgLOD3EbFTZt47yGlcT9VPiYib6/ez0U3A26n68ZsBMnNBRPwOeDnVHzwafRb4cr3dsohYRDUq2Fjja4DZPDWMSlLb8xo+SWqhzFycmd+Bv4yafRz4Vv+wVzsN2JsqVO1OFShe2bey3v9fqALOPKrQ8a6ImEUVgqZn5p7A/1PvsvMgywdVj4S9EvhRvWgScHVmBrAA+BrVFM29gYOBMyNi34jYA/gI8PLMfB7wLeDd/Zo/B/h4ve8bgBf3O/bWdftvr9t4HfCFiJhTb3Iw8NbM3B34OXD2IKfyyohYEBG/i4hHgP+kCry/qAP2hp7HPsAOVFMfnwN8bojjN57XZsD/B3ygrv2NwH9ExFD/V+8OvKqu4xLg9Q3rXg98JiJ2AT5EFer2Ak4GvhERm2fm/Zm550Bhr3Ya8MV6/Q+B9U4djoipwAnU/SIz96/bbvx4MzALmJCZDzXs/ifgGf3bzMz/7hv1i4iXA/sD1zYcc1J9bqdn5pr11SZJ7coRPkkaAyJic6qpaztRjXIM5CXA5zNzVf36lfW+74e/jLodCRwREccDc6lGmDYHbgQ+VF+L933gE5m5KCLWDrR8Pcf/WES8p24T4NtUo0t9flp//nuqEbvLqhmrQHV91V715+v6Rogy8xP1ORzS0M5XgE/X5/IDqhHLRvtQXcv387qN30bETcAhVCOC8zPzT/W2twHHrOd8oJ7SWYeGTwHPAa7e2POoz+U9wJsi4ll1TSsGOX6j5wJr+/4AUE9NfG7d5mD73ZuZ99Rf/xiYUl8TuZJqFPB64FRge+D6hrbWAc8GfrW+hiNiO+Aoqj80QBVgL46ID2TmE/Wyd9QjbFD9XvET4F31/usb4fsg1feqUQfVaOn6ajmB6g8ixzaMiEM1dfQPmXnj+vaVpHZm4JOkFouIZ1KFjC7gRX2BLiKuoRotAngv1TTO3ob9tqVhpkYdGm+nuunIT4HLqH5Z78jMu+ubXxxCNWL2g4g4OTOvXt/yAUr9yzV86/F4/XkisKweNWysdRnVyFLjOUyl3/S8zPyviLgaOJQq/L4//jbxTOSpYWEC1Q1DVgOrGpb3Ah0N0xb7HN7vmKsj4i1UU1o/BrxtI8/jWVQh+HyqKa4Lgb4wNJS/+f7W7e5etwF10K7DaaO+970v9H+WapSth+oGJ70RMRG4PjMbR4R3AtY3qtfnjXVNV9ffgglUN7Z5HdV1etDvGr5Gmbn/QMvr0dOOiJiZmY/Wi3egGuXrv20H1c1ZjgVekpkL+m3ySqppyZKkATilU5JaKCKmU43KfCMzj2sYvSMzD2+YBvctqtGu4yNicj3N7yLgVQ3N7UL1y/h76sB2CDAZmFhfy/XfwPcy851UNyR5/vqWb+JpJbCqb9SnDha/oRol+hHwkojYvt72TdTXezW8JzcDe2Xm5VTBaitgu4ZNfgbsGhEvqLffDTiI6n0cuKC/Tlvs+3hK0Kmn0Z4KnBYRe23kebyUamrrRVTXYx5FFRyHI4HeiHhpfbznU02hnEB1F8x59XbHD9HO5cArgH/kr0HoeuDQiNi1bvtwqpvTTF1fI3VIfCNwSmbOrj+eSTV98u11ENso9dTL71B9f4mI51GNrv54gM0/SvX9ndc/7NU1HFSfnyRpAAY+SWqtt1CNDB1dX0vW97H1ANv+F9UI1HzgDmAJ1Q0++vyaaprlwojoAo4E7qSatncFVfC4MyLmA1vW+65v+Uarg9M/ACdFxK+B7wH/lpk3ZeYdVI+guDYifkU1gndKvybOAj4QEbdTBYBzMnNxQ/sPU4WZ/4yIO4ArgRMz865Nqbtu+0aqu1F+GnhyI87jYuCQuq7bqB5RMGcY1+GRmT1U00/fFxEL6raOqd/Pt1FNc72NaqrukkHaeaA+9q/7gm1m3kkVrr5U1/t/gVdk5uMRsUPd53bo19QRVL8nfLHf8guoAvjhbJrTgAMi4jf1MV6bmcugGt2OiFdExDOAM6iu+ft+w8/HiXUbs4AtGqbwSpL66ejtHdHHDEmSJEmSxghH+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCjYvn8N122229U6eu987RUsv09PQwefLkVpchDcj+qbHKvqmxzP6psWrlypUP77333tts6H7jIvB1dHQwd+7cVpchPUVXV5d9U2OW/VNjlX1TY5n9U2PV/Pnz79mY/ZzSKUmSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFalrgi4h9IuLHAyw/MiJ+GRE/i4g3Nuv4kiRJktTumhL4IuIs4FJgSr/lmwEXAIcCBwMnR8R2zahBkiRJktpdZ5Pa/T1wDPD5fsvnAosycylARNwIvBD46mCN9fR0cNddzSizTDNnwqxZra5CkiRJUqs1JfBl5tcjYvYAq2YAyxperwC2HKq97m746lfvG6HqyrZ6dQdbbLGOQw9dwaRJra6mfN3d3XR1dbW6DGlA9k+NVfZNjWX2T5WmWSN867McmN7wejrw2FA7TZwI/+t/7cgEbzEzpD/+ER57DCJgypSht9em6erqYu7cua0uQxqQ/VNjlX1TY5n9U2PV/PnzN2q/0Q58XcAuETETeBw4CDhvODt2dFTBT4MzFEuSJEnqMyqBLyKOB7bIzEsi4gzgOqobxlyWmc7VlCRJkqQmaFrgy8zFwL7111c2LL8auLpZx5UkSZIkVZwAKEmSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUqM5mNBoRE4ALgT2AHuCkzFzUsP5M4FXAOuBDmXlVM+qQJEmSpHbWrBG+o4ApmbkfcDZwft+KiNgKeBuwH3Ao8Ikm1SBJkiRJba1Zge9A4FqAzLwFmNew7gngHmDz+mNdk2qQJEmSpLbWlCmdwAxgWcPrtRHRmZlr6tf3AncCE4EPD9VYby8sXnw3EyeOfKGluf/+TpYtm8jChcuZPLm31eUUr7u7m66urlaXIQ3I/qmxyr6pscz+qdI0K/AtB6Y3vJ7QEPYOA7YH5tSvr4uImzLzF+trrKMDZs+eQ2ezqi3IhAkwbRrsuusOTJnS6mrK19XVxdy5c1tdhjQg+6fGKvumxjL7p8aq+fPnb9R+zZrSeRNwOEBE7Avc0bBuKbAK6MnMbuAxYKsm1SFJkiRJbatZY2ZXAS+NiJuBDuDEiDgDWJSZ34qIlwC3RMQ64Ebg+02qQ5IkSZLaVlMCX2auA07pt3hhw/r3Ae9rxrElSZIkSRUfvC5JkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFMvBJkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVKjOZjQaEROAC4E9gB7gpMxc1LD+MOB99cvbgDdnZm8zapEkSZKkdtWsEb6jgCmZuR9wNnB+34qImA58DDgiM/cFFgOzmlSHJEmSJLWtpozwAQcC1wJk5i0RMa9h3f7AHcD5EbEzcGlmPjRYY729sHjx3Uyc2KRqC3L//Z0sWzaRhQuXM3myg6bN1t3dTVdXV6vLkAZk/9RYZd/UWGb/VGmaFfhmAMsaXq+NiM7MXEM1mvciYE/gceCnEfGzzLxrfY11dMDs2XPobFa1BZkwAaZNg1133YEpU1pdTfm6urqYO3duq8uQBmT/1Fhl39RYZv/UWDV//vyN2q9ZUzqXA9Mbj1OHPYBHgF9m5gOZ+ThwA1X4kyRJkiSNoGYFvpuAwwEiYl+qKZx95gO7R8SsiOgE9gXubFIdkiRJktS2mjVJ8irgpRFxM9ABnBgRZwCLMvNbEfEu4Lp6269k5m+aVIckSZIkta2mBL7MXAec0m/xwob1XwK+1IxjS5IkSZIqPnhdkiRJkgpl4JMkSZKkQhn4JEmSJKlQw7qGLyL2BE4G/vJkt8x8Q7OKkiRJkiRtuuHetOVy4FPAvc0rRZIkSZI0koYb+B7IzEubWokkSZIkaUQNN/AtjoizgduBXoDM/F7TqpIkSZIkbbLhBr7JQNQfUIU+A58kSZIkjWHDCnyZeWJE7A48B7grMxc0tyxJkiRJ0qYa1mMZIuKtwGeA/YFLIuLMplYlSZIkSdpkw30O3/HACzPzdOAA4JXNK0mSJEmSNBKGG/g6MnMNQGY+CTzZvJIkSZIkSSNhuDdtuTEivgb8FHghcFPzSpIkSZIkjYRhjfBl5pnAfwObAZdl5r82tSpJkiRJ0iYbNPBFxBH155OBHYHlwDPq15IkSZKkMWyoKZ1b15+3b3YhkiRJkqSRNWjgy8zP1Z/PiYgtgXXAUcC3R6E2SZIkSdImGNZNWyLiCuB7VM/hmwAcAxzdxLokSZIkSZtouI9lmJ2ZXwDmZuYpwIwm1iRJkiRJGgHDDXyTIuKfgDsjYhZ/vbZPkiRJkjRGDfc5fB8FjgPOAN4GvKdpFUmSJEmSRsRQj2XoC4TfBl4DPAicS3U9nyRJkiRpDBtqhO8K4Hgggd5+63ZuSkWSJEmSpBEx6AhfZh5ff7kzcHBm7gy8sv4sSZIkSRrDhnvTlouA19VfvyYiPtGkeiRJkiRJI2S4gW+vzDwXIDPfDjy/eSVJkiRJkkbCcANfR0RsDRARWzH8u3tKkiRJklpkuMHtA8CtEbEU2BI4rXklSZIkSZJGwrBG+DLz28CzgSOAZ2fmdU2tSpIkSZK0yYYV+CLiYOBXwPXAORHxz02tSpIkSZK0yYZ7Dd//BQ4CHgA+hFM6JUmSJGnMG27gW5eZjwK9mdkNrGhiTZIkSZKkETDcwLcoIj4MbB0RZwP3NLEmSZIkSdIIGG7gO40q5N0IPAG8sWkVSZIkSZJGxHAfy/DtzDy0qZVIkiRJkkbUcAPfYxHxD0AC6wAy866mVSVJkiRJ2mRDBr6ImAHMAU5vWNwLvLhZRUmSJEmSNt2ggS8i3gL8C7AW+LfMvHZUqpIkSZIkbbKhbtpyPBDAvsDbm1+OJEmSJGmkDBX4ujNzdWY+DEwajYIkSZIkSSNjuI9lAOhoWhWSJEmSpBE31E1bdouIK6nCXt/XAGTm8U2tTJIkSZK0SYYKfP/U8PXFzSxEkiRJkjSyBg18mfmT0SpEkiRJkjSyNuQaPkmSJEnSOGLgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQnU2o9GImABcCOwB9AAnZeaiAbb5DvDNzLy4GXVIkiRJUjtr1gjfUcCUzNwPOBs4f4BtzgVmNun4kiRJktT2mhX4DgSuBcjMW4B5jSsj4lhgHfDdJh1fkiRJktpeU6Z0AjOAZQ2v10ZEZ2auiYjdgeOBY4H3Dqex3l5YvPhuJk5sQqWFuf/+TpYtm8jChcuZPLm31eUUr7u7m66urlaXIQ3I/qmxyr6pscz+qdI0K/AtB6Y3vJ6QmWvqr08AdgR+CMwGVkfE4sy8dn2NdXTA7Nlz6GxWtQWZMAGmTYNdd92BKVNaXU35urq6mDt3bqvLkAZk/9RYZd/UWGb/1Fg1f/78jdqvWRHqJuBI4CsRsS9wR9+KzDyr7+uIeD/wwGBhT5IkSZK0cZoV+K4CXhoRNwMdwIkRcQawKDO/1aRjSpIkSZIaNCXwZeY64JR+ixcOsN37m3F8SZIkSZIPXpckSZKkYhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEJ1troAjayVK2HVKvjd72Dy5FZXM/atWFF9nj594/ZfvHgSEyeOXD3jwcyZMGtWq6uQJEnScBj4CrR6Ndx9t4FvOJ54ApYvh222gc6N+Gn40586mdBG4+Td3TB1Khx0EEyZ0upqJEmSNBQDX4FWrqw+b0yAaTd//jM8/DBssQU87Wkbvn9nZ3u9z489BkuWwLx5Bj5JkqTxoI1+VW0v06fDjBmtrmLsmz79r4Fvq602fP+lS9dt1H7j1bJlsGZNq6uQJEnScLXRZDRJkiRJai8GPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqVGerC5CkUj38MDz0EPT0tOb4f/jDpJYde1Nsvz1su22rq5AkqQwGPrW1zTeHadNg6tRWV6ISPfooLF4M994LEyeO/vGXLJnC0qWjf9xN8cQTsNdeBj5JkkaKgU9t7ZnPrD6kZpk8GebMgZkzR//YW265mjlzRv+4m2LBAli3rtVVSJJUDq/hkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSpUZ6sLkDR+rFwJK1bAggWw1VatrmbsW7kSnnwSJvinNUmS1CIGPkkb5PHH4be/halTW13J+DB9Omy/faurkCRJ7aopgS8iJgAXAnsAPcBJmbmoYf07gOPql9dk5jnNqEPSyOvthZ12qj4kSZI0tjVrotFRwJTM3A84Gzi/b0VE7Ay8Gtgf2A84NCKe16Q6JEmSJKltNWtK54HAtQCZeUtEzGtYdy/w8sxcCxARmwHdgzXW2wuLF9/NxIlNqrYgS5d2snz5ZtxzTw9bbLGu1eUUr6enh7vvvrvVZYya++6bxIMPbsa99/awZs2aVpejIYzH/rlkyWQ6O1fz9KevanUpaqLu7m66urpaXYY0IPunStOswDcDWNbwem1EdGbmmsx8Eng4IjqAjwG3Z+ZdgzXW0QGzZ8+h0ysOhzRnDuyyC8yaVb1vaq67776bOXPmtLqMUdPdDatXO6VzvBiP/XPZMpg9G+bObXUlaqauri7m+k3WGGX/1Fg1f/78jdqvWVM6lwPTG4+TmX8ZDoiIKcAX621Oa1INbWubbQx7kiRJkpoX+G4CDgeIiH2BO/pW1CN73wR+lZlv6pvaKUmSJEkaWc2aJHkV8NKIuBnoAE6MiDOARcBE4GBgckQcVm//rsz8WZNqkSRJkqS21JTAl5nrgFP6LV7Y8PWUZhxXkiRJkvRXzZrSKUmSJElqMQOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVKhmPZZBkqQNtmoVPP443HVXqysZP2bOhFmzWl2FJGmsMvBJGrbNN4epU2GCcwPUJCtXwp/+VAU/Da27G+bMMfBJktbPwCdp2J75TNh+e5g4sdWVqFRPPgkPPgi77dbqSsaHhQurEVFJrffww/Doo62uYnxxhsLoMPBJ2iCbbdbqCtQOpk5tdQXjgz+P0tjx0EMwf36rqxg/ururwHfMMa2upHwGPkmSJD1Fu45YLV48aaNmsixfDkuXwgteMPI1leiee6r3S81n4JMkSdJT/PnP0NUFnW322+K9925GT8+G77d8Oaxe3X7v18by8pDRY5eUJGmcWrkSnnhi/N3VdGNHUEaC1wwN35o11QhMRKsrGV0rVqxj5swN3++++6qfSWmsMfBJkjROrVkDjz0GS5a0upIN8+CDE5k2bfSPu2pVNQpj4Bu+jo7qDs3tZOrU3o065ylTRr4WaSQY+CRJGqdWraoC3447trqSDbN69QS6u0f/uIsXV1PupGaYMcNr0jQ2GfgkSRrnxtuI1YoVa1tS8913V3dS/PnPR//Y49Gjj7JR17K1q513rj6kscbAJ0kaM3bcEdata3UVKlVPDzzyCPT2trqS8WHVKh/9IZXAwCdJGjOe+9xWV6DSrVsHe+3V6irGhzVrqkczSBrfJrS6AEmSJI09nZ2w3XatrkLSpjLwSZIkSVKhDHySJI1TW20FU6e2ugpJ0ljmNXySJI1Te+/d6grGl+nT4cknW12FJI0uA58kSWoLe+zhXWAltR+ndEqSpLYxwd98JLUZ/9mTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSpUZ6sLkCRJktReVq6EVavgrrtaXUn5DHySJEmSRt3q1XDbba2uYvzYcccJUzdmPwOfJEmSpFE1bRqsWwc77dTqSsaP1as7NtuY/Qx8kiRJkkbV7NkwYwZMmdLqSsaP1atQ/OxlAAAgAElEQVQ3bj9v2iJJkiRp1M2c2eoK2oOBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVBNefB6REwALgT2AHqAkzJzUcP6NwJvAtYA52bmt5tRhyRJkiS1s2aN8B0FTMnM/YCzgfP7VkTEdsDbgAOAlwEfjojJTapDkiRJktpWswLfgcC1AJl5CzCvYd0LgJsysyczlwGLgOc1qQ5JkiRJaltNmdIJzACWNbxeGxGdmblmgHUrgC0Ha2zSpLWPrVy54KGRL1PaNFtvDcuXL2h1GdKA7J8aq+ybGsvsnxqrpk5d+/SN2a9ZgW85ML3h9YQ67A20bjrw2GCN7bPP3k8b2fIkSZIkqXzNmtJ5E3A4QETsC9zRsO4XwAsjYkpEbAnMBX7TpDokSZIkqW119Pb2jnijDXfpfB7QAZxIFQAXZea36rt0nkwVOD+UmV8f8SIkSZIkqc01JfBJkiRJklrPB69LkiRJUqEMfJIkSZJUKAOfJEmSJBWqWY9l2CgNN3vZA+gBTsrMRQ3r3wi8CVgDnJuZ325JoWo7w+ib7wCOq19ek5nnjH6VakdD9c2Gbb4DfDMzLx79KtWuhvFv52HA++qXtwFvzkxvLqCmG0bfPBN4FbCO6gaDV7WkULWtiNgH+EhmHtJv+ZHAe6ny0GWZ+Zmh2hprI3xHAVMycz/gbOD8vhURsR3wNuAA4GXAhyNickuqVDsarG/uDLwa2B/YDzg0Ip7XkirVjtbbNxucC8wc1aqkymD/dk4HPgYckZn7AouBWa0oUm1psL65FdXvnPsBhwKfaEmFalsRcRZwKTCl3/LNgAuo+uXBwMl1RhrUWAt8BwLXAmTmLcC8hnUvAG7KzJ7MXAYsonrsgzQaBuub9wIvz8y1mbkO2AzoHv0S1aYG65tExLFUf6H+7uiXJg3aP/enek7v+RHxU+DPmfnQ6JeoNjVY33wCuAfYvP5YN+rVqd39HjhmgOVzqR5ztzQzVwM3Ai8cqrGxFvhmAMsaXq+NiM71rFsBbDlahantrbdvZuaTmflwRHRExHnA7Zl5V0uqVDtab9+MiN2B46mmfkitMNj/67OAFwHvBA4DTo+Ivx/l+tS+BuubUP0x906qqcafHM3CpPoZ5U8OsGqj8tBYC3zLgekNrydk5pr1rJsOPDZahantDdY3iYgpwBfrbU4b5drU3gbrmycAOwI/BF4PnBERLx/d8tTmBuufjwC/zMwHMvNx4AZgz9EuUG1rsL55GLA9MAd4JnBURLxglOuTBrJReWisBb6bgMMBImJfqqkefX4BvDAipkTEllRDmr8Z/RLVptbbNyOiA/gm8KvMfFNmrm1NiWpT6+2bmXlWZu5TX/B9OfDxzLy2FUWqbQ32//p8YPeImFWPrOxLNaIijYbB+uZSYBXQk5ndVL9QbzXqFUpP1QXsEhEzI2IScBDws6F2GlN36QSuAl4aETcDHcCJEXEG1VzVb0XEJ4GfUgXVd9c/hNJoWG/fBCZSXTg7ub7jHMC7MnPIH0BpBAz672ZrS5OG/H/9XcB19bZfyUz/kKvRMlTffAlwS0Sso7pO6vstrFVtLiKOB7bIzEvqfnodVR66LDPvG2r/jt5e734sSZIkSSUaa1M6JUmSJEkjxMAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFWqsPZZBkqSmiohDgK9QPfOtF5gB/AF4dWau3oR2ZwNfysx9I2IxsKuPD5IktZqBT5LUjn6Ymcf1vYiIK4FXAF9rXUmSJI08A58kqa1FxCRge2BpRHwYOIjqkoePZ+ZXI2If4D+oHs58H/Bq4AXA++ompgEnABs9OihJUrN4DZ8kqR29OCJ+HBF3ArcBVwGTgDmZeQDwIuDdEbEVcAlwYmbuA/wAmAvsBrwmM18MfAv4x1achCRJQ3GET5LUjn6YmcdFxNbA94G7gecCe0fEj+ttNgP+Dtg2M7sAMvNCgIjYCfhkRDwO7AjcNMr1S5I0LI7wSZLaVmY+ArwGuBT4M/CjzDwEeDHVjV3+ANwfEbsARMQ7I+LoevsTM/P1wP1U0z0lSRpzDHySpLaWmXcCnwSOAB6PiJ8C84HezFwBvAm4LCJ+AuwFXAN8Hvh5RNwETAd2aEnxkiQNoaO3t7fVNUiSJEmSmsARPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUAY+SZIkSSqUgU+SJEmSCmXgkyRJkqRCGfgkSZIkqVAGPkmSJEkqlIFPkiRJkgpl4JMkSZKkQhn4JEmSJKlQBj5JkiRJKpSBT5IkSZIKZeCTJEmSpEIZ+CRJkiSpUJ2tLkCS1HwR0Qv8BlgL9ALTgOXAqZl5a73N5sA5wCuAnnq7q4FzM3NVQ1uvA04BpgKTgBuBszLzsVE7oU0UEecDbwV2zsw/NSy/HPhNZp7Xb/vHgd0zc3H9etjvQUTsCpwP7FQvWgq8OzNvHOHTGjERsQvwWWAW8DhwQmYuHGC75wCXAFtQ9ZezM/O6iDgbOK5h022A6Zk5o+nFS5L+hiN8ktQ+XpSZe2bmXpkZwJeB/wSIiE7gB1T/L+yZmc8F9qX6Rf66ej0R8X+Ak4CjMnNPYA/gSapgOC5ExBTgBOBrwFs2Yv8NfQ++Dlyamc/LzOcB/wZ8JyJmbkz9o+SLwMWZ+RzgfcDXIqJjgO0uBC6r34c3AF+JiM7M/Pe6r+0JHAI8AbxylGqXJDVwhE+S2lAd4J4JPFov+kdgQmae0bdNZq6MiNOB24GjI+Ia4F3A8zPzz/U2T0bEv9brJ2Xm6n7HOQI4lypIPkE1KraMahRti3qb2X2vI+L1wD8Dm9fbTQbOz8yv19t+pD7uOyPin4HT6rYfAd6SmQsjYh5VwNpzPad/HPB74OPA9yLiA5m5cpjv2+Yb+h4A29fn0/e+3hAR/0Q12jrge5SZv4qIo6jC1gRgBXBGZv4iIt4P7AfsAPwqM18TEe8G/ne97WLgtMy8v1/tJwBn8FSvzcw7GrbbEdgV+FJd73cj4iJgL+C2fvtOBJ5Wfz0d6B6g/fOA72bmdwdYJ0lqMgOfJLWPH9VTO2dR/WL+beDEet3+wA39d8jM3oi4HjgQ+AOwKjN/12+blVQjQn8jIrYFvkA1snh7RBwD/Dtw6hB17gbMzszlEXFiXePXI2Ii8BrgkIg4GHgd8MI6mB4KXAXMraeori/sQRUSr8jMWyNiSd3ORUPU1GdXNuA9qL0ZuDAiPko19fMG4MrMXLa+9ygi3gFcDOyfmX+IiBcD34yIqNv8O6oppmvqIPdc4AX165OBS4HD+9V4BXDFMM5xJ+D+zFzXsOxPwDN4auB7M/DDut6nA8dl5pq+lfWUz6OAZw3juJKkJnBKpyS1jxfVUwqPoLqG70eZ+WDD+s3Ws99kquuz1rFh/28cQDVydztAZn4jMw8bxn6/zszl9ddfBvaLiO2AlwF31WHr/wWeDdwcEQuAjwJPG2qaZEQ8n2oK5v/Uiz4HvL1huuK6AXesznstG/4ekJn/QzXKdwKwkGrq4531yOb63qMXA9dn5h/q5T8EHgT2rpu9pSFYHUE1/fbW+r14K9AXDBvP/YSIWDDAx3MHONfefss66vNvbG8K1ffn9Zn5DOAg4L8iYqeGzU4HPpWZy4Z+pyRJzeAInyS1mcy8rR6RuTwibq9vRHITcFZETGgc2YmICVS/yJ8L3AlsFhG7NI5w1b/4fwM4qd80wjU0BIc6VD2Xaqpm4/Vgk/qV+HhDrSsj4qvA8VTTGC+tV00EPp+Z72yocweqG6IM5s11XfPrwbLOer/DgGuAh4GtG3eIiOnAlLrtBzfkPahv2PL6zDyb6hrJHwDvjYgfAMcCd63nPZrIU0PXBP4ayh9vWD4R+EhmXlS3MZm/TrP8iw0Y4fsjsH1EdGRmXw07UI3yNdodmJaZ367bvyUifgvsA9xbj8j+b/4aUiVJLeAInyS1oXrU6RfABfWir1FdP/aJiJgKUH/+T6pwcVVm9gAfAT5bT0XsCxcXAJv3v2YM+DkwNyJ2q1//A9X0xceASfV0P4BXDVHuZ6imXR5AdQMUgOuAV0XE9vXrU4DrB2skIraiun7viMycXX88o67p9Hqz7wL/FBE71Pt01OtuyMzHN+I9+DNwckQc21DHTGBHqumR63uPrgdeFhE71/u8mGqq5c8HOLXrgJMiou8OmB8APj/YezGY+q6li6hvshIRL6Ma2byj36aLgC0jYv96u2cBz6G65hOq4Lq0786mkqTWMPBJUvt6C3B4RLysnh54KFW4mx8Rv6EKJI8DL83MJwEy80NUoeu6evrgr6hG6/6hf+P1TU1eDXyu3vYMqmu8lgFnAd+NiF8Cq/rv26+d+VTTCb+Wmd31su9RBa/vR8SvqUYAj6mvOZxXH6+/1wF3ZuaP+i0/F3hxROxer/sIcE3dxkKqawr/Eko38D1YSjU9858jYnE9AvYD4EOZ+cNB3qM7qa41/Eb9vfh34Mj1TI28lOp6zL4RtucBr1//OzosrwJOqY/9QeAf+0Z+62mg8+pHUBwN/EdE3EH1R4OTM/P3dRu7UN1ARpLUQh29vf1njEiSJEmSSuAInyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklSocfEcvgULFvROnjy51WU8RU9PD2OxLpXB/qVmsn+p2exjaib7l5pprPavlStXPrz33ntvs6H7jYvAN3nyZObOndvqMp6iq6trTNalMti/1Ez2LzWbfUzNZP9SM43V/jV//vx7NmY/p3RKkiRJUqEMfJIkSZJUKAOfJEmSJBXKwCdJkiRJhTLwSZIkSVKhDHySJEmSVCgDnyRJkiQVysAnSZIkSYUy8EmSJElSoQx8kiRJklQoA58kSZIkFcrAJ0mSJEmFalrgi4h9IuLHAyw/MiJ+GRE/i4g3Nuv4kiRJktTumhL4IuIs4FJgSr/lmwEXAIcCBwMnR8R2zahBkiRJktpdZ5Pa/T1wDPD5fsvnAosycylARNwIvBD4apPqkCRJ0jBc+fM/8s0F97W6jGFZuXIl0254rNVlqDCrVq3ioYce4vh9ZzN3bqurGTlNCXyZ+fWImD3AqhnAsobXK4Ath2qvp6eHrq6uEapu5HR3d4/JulQG+5eayf6lZrOPjT//c/P9/OHR1ew8c1KrSxnSunXrWLlyZavLUCFWrFjBAw88wGOPPUZHRwdLZk8p6t+vZo3wrc9yYHrD6+nAkH+emTx5MnPHYMzu6uoak3WpDPYvNZP9S81mHxt/pt3wGLtPm8aX37Rfq0sZkv1LI2HFihUcfPDB3H777cyaNYvTTjuNU089laVLl47J/jV//vyN2m+0A18XsEtEzAQeBw4CzhvlGiRJkiS1oUceeYSbbrqJV7ziFUyfPp158+Zx2mmn8epXv5qpU6cCsHTp0hZXObJGJfBFxPHAFpl5SUScAVxHdcOYyzJzfEwWlyRJkjQuLVy4kE984hNcccUVrF27liVLljBz5kwuueSSVpfWdE0LfJm5GNi3/vrKhuVXA1c367iSJEmSBNX03zPPPJNrrrmGyZMn89rXvpbTTz+dmTNntrq0UTPaUzolSZIkqWm6u7t55JFH2HHHHZk6dSoLFizgnHPO4ZRTTuHpT396q8sbdQY+SZIkSePegw8+yEUXXcSFF17IvHnz+M53vsPs2bP54x//yMSJE1tdXssY+CRJkiSNW3feeScf//jH+cIXvkBPTw+HH344Z5xxxl/Wt3PYAwOfJEmSpHGmt7eX3t5eJkyYwFVXXcWVV17JiSeeyNvf/nZ23XXXVpc3pkxodQGSJEmSNByrVq3iM5/5DLvvvjtf/epXAXjrW9/Kvffey0UXXWTYG4AjfJIkSZLGtAceeIBPf/rTXHzxxTz88MPstddebLnllgDMmDGjxdWNbQY+SZIkSWPay1/+cn79619z5JFH8o53vIODDz6Yjo6OVpc1Lhj4JEmSJI0Z69at45prruHSSy/lC1/4AltssQWf+tSn2Hbbbdlll11aXd644zV8kiRJklruiSee4KKLLmLu3LkceeSR3Hrrrdx1110AHHjggYa9jeQInyRJkqSWWrJkCbvtthtLly5l3rx5XHnllRx77LFsttlmrS5t3DPwSZIkSRp1t912GwsWLOANb3gD22+/PaeeeiqHHXYYBxxwgNfnjSADnyRJkqRRsXbtWq6++mouuOACbrjhBrbZZhuOP/54pkyZwgc/+MFWl1ckr+GTJEmS1HQ/+clPiAiOPvpoFi9ezHnnncfvfvc7pkyZ0urSiuYInyRJkqSmuPfee+nu7maXXXZhhx12YNttt+XDH/4wRx99NJ2dRpHR4AifJP3/7N15nI/1/v/xx8zQDDFCmxhZu5iIUseSdErJUiFJqbQ6VCeMjnyrc452LZpBllRSkpKSpZQ2HSepjqRT4QpZIpwK2Qczn98fqZ/v+bYMzWeuWR73283NfLZrnrh8Zp7zel/XJUmS8tWHH37IJZdcQs2aNbn55psBqFu3LnPnzqVr166WvQJk4ZMkSZKUL1599VVatmxJ06ZNmTlzJv369WPo0KFRxyrRrNaSJEmSDtqWLVs49NBDSUpK4oMPPuDrr79m6NChXH311ZQvXz7qeCWeEz5JkiRJB2zlypX079+fatWqMW3aNABuvvlmli5dSt++fS17hYQTPkmSJEl5Nm/ePDIzM5kyZQqJiYl07dqV4447DoCyZctGnE7/zcInSZIkKU9yc3O5/PLL+e677xgwYAB//vOfqVatWtSx9CssfJIkSZJ+1ubNm3n88cd59tlneffddylTpgxTpkyhVq1alCtXLup4ygOP4ZMkSZL0vyxfvpw+ffpQrVo1BgwYQGpqKhs2bADghBNOsOwVIU74JEmSJP1k8eLFHH/88ZQqVYqLL76YjIwMTjzxxKhj6SBZ+CRJkqQSbM+ePUyePJl169Zx0003Ua9ePYYNG0aXLl045phjoo6n38klnZIkSVIJtHHjRu677z5q1qzJpZdeysSJE8nNzSUhIYEbb7zRsldMOOFTiTLxg9VMW7g26hh5smPHDsrO2Rx1DBVT7l+KN/exomfRui2kV0mNOoYKyLPPPsu1117Ljh07OOuss3j00Udp27YtiYnOg4ob/0VVokxbuJZF67ZEHUOSpEInvUoqHRtXjTqG4iQWizF79mw+++wzABo1asRFF13EJ598whtvvEH79u0te8WUEz6VOOlVUpnUq3nUMX7T4sWLqV+/ftQxVEy5fyne3MekwmH37t0899xzZGVlsXDhQq666iqeeOIJ0tPTGTduXNTxVACs8ZIkSVIx9PDDD1OjRg2uuOIKdu/ezeOPP86oUaOijqUC5oRPkiRJKibCMKRu3bokJiaybt06TjjhBJ588knOPvtsEhISoo6nCDjhkyRJkoqwWCz203F49erVY+bMmQDcfffdvPbaa7Rp08ayV4JZ+CRJkqQiaM+ePYwbN45GjRrRpk0bFixYwJ133knTpk0BPAmLAJd0SpIkSUXK7t27OeSQQ0hISOCOO+6gQoUKjBs3jksuuYTk5OSo46mQsfBJkiRJRcBnn31GVlYWb731FmEYkpyczNy5cznmmGNcsqlf5JxXkiRJKqRisdhPx+E1bNiQZ599lnbt2rF9+3YAqlatatnTr3LCJ0mSJBVSc+fOpV27dlSpUoV77rmHXr16Ubly5ahjqQix8EmSJEmFxPr16xk5ciRJSUncfvvtnHrqqUyZMoUOHTpwyCGHRB1PRZBLOiVJkqSIffLJJ1x55ZVUr16de+65h2XLlgGQkJBA586dLXs6aBY+SZIkKUIPPPAAjRs3ZvLkyfzpT38iDEMmTJgQdSwVEy7plCRJkgrQ9u3beeqppzj11FNp1KgR7du3B6Bnz55UrFgx4nQqbix8kiRJUgFYu3YtI0aMYMyYMWzatInbbruNRo0a0aBBAxo0aBB1PBVTFj5JkiQpzv785z8zZswYcnNz6dSpExkZGZx66qlRx1IJ4DF8kiRJUj7LycnhtddeIxaLAXDEEUdwww03sHTpUl588UVatmzp9fNUIJzwSZIkSflk27ZtjBs3jmHDhrF8+XLeeOMNzjrrLAYNGhR1NJVQTvgkSZKk32nr1q3cfPPNVKtWjT59+nDkkUfy/PPP88c//jHqaCrhnPBJkiRJB+mbb77hiCOOIDk5meeff55zzjmHjIwMmjVrFnU0CbDwSZIkSQckJyeHqVOnkpmZyapVq1ixYgWHHHIIixcvpkyZMlHHk/4Xl3RKkiRJebBlyxaysrKoU6cOF154IevWrWPAgAHk5OQAWPZUKDnhkyRJkn5FLBYjISGBefPm0b9/f0477TQyMzM5//zzSUpKijqe9KssfJIkSdLPmDdvHpmZmdSpU4fBgwfTpk0bPv74Yxo3bhx1NCnPXNIpSZIk7bN3714mTZpEs2bNaNGiBW+++SblypUDICEhwbKnIscJnyRJkrRPRkYGI0aMoE6dOowYMYIrrrjip8InFUVO+CRJklRiLV++nL59+/Lpp58C0Lt3b6ZPn04Yhtxwww2WPRV5TvgkSZJUosRiMd59910yMzOZNm0apUqVomHDhjRs2JDjjz+e448/PuqIUr6x8EmSJKnEiMVitG7dmtmzZ1O5cmVuvfVWrr/+eo455pioo0lxYeFTsTPxg9VMW7j2Zx9btG4L6VVSCziRJEmK0saNG3nhhRfo2bMnCQkJtG/fnm7dunH55ZdTtmzZqONJcWXhU7EzbeHaXyx26VVS6di4agSpJElSQfviiy8YNmwYTz75JDt27ODkk0/mpJNO4i9/+UvU0aQCY+FTsZReJZVJvZpHHUOSJEVg3bp1/OlPf+Lll1/mkEMO4bLLLqNfv340bNgw6mhSgbPwSZIkqcjLzs7myy+/pH79+lSqVIlVq1YxaNAgrrvuOo466qio40mRsfBJkiSpyPr222955JFHGDlyJMnJySxbtozk5GQ++eQTEhISoo4nRS4uhS8IgkRgFNAIyAauDcNw2X6P/wW4BMgF7g3D8KV45JAkSVLxtGzZMh588EHGjx/Prl27aNu2LRkZGSQlJQFY9qR94jXh6wSkhGHYPAiCZsBDQEeAIAgOA/oAdYBDgYWAhU+SJEm/KhaLkZ2dDcDixYsZP348PXr0oG/fvqSnp0ecTiqc4lX4WgKvAYRh+H4QBCfv99h2YBU/lL1D+WHK96uys7NZvHhxPHL+Lrt27SqUuUq6HTt2ABT5fxv3L8WT+5fizX1M+Sk7O5uXX36Z8ePHc8YZZ9C7d29q1arFW2+9RcWKFYGi/3VfhUdxe/+KV+FLBb7f73ZOEASlwjDcu+/2V8AiIAkY/FsbS05Opn79+vmf8ndavHhxocxV0pWdsxmgyP/buH8pnty/FG/uY8oPGzZsYPTo0YwaNYpvvvmGE044gbPOOouUlBT3L8VNYX3/+uijjw7qdYn5nONHW4Dy+3+e/cpeO6AKUBOoDnQKguAPccohSZKkIqpfv37ccccdNG3alLfeeouFCxfStWvXqGNJRUq8Ct9coD3AvmP4Pt3vsU3ATiA7DMNdwGbgsDjlkCRJUhGQm5vLq6++Sps2bX5aTnfHHXewZMkSZsyYwZlnnumJWKSDEK8lnS8BZwdB8B6QAFwVBEF/YFkYhtODIDgLeD8IglzgXeCNOOWQJElSIbZjxw6efvpphg4dypIlSzjmmGNYuXIl9evX57jjjos6nlTkxaXwhWGYC/T+r7uX7Pf4IGBQPD63JEmSioY9e/ZQv359Vq9ezUknncSECRPo2rUrhxxySNTRpGLDC69LkiSpwCxcuJCpU6cyaNAgSpcuzV//+leCIOC0005zyaYUBxY+SZIkxVVubi6vvPIKWVlZzJ49m0MPPZQrr7ySGjVq0LNnz6jjScVavE7aIkmSJLFo0SLq1avH+eefz9KlS3nggQf46quvqFGjRtTRpBLBCZ8kSZLy1dq1a1m1ahUtWrSgZs2a1K5dmzvvvJMuXbpQunTpqONJJYqFT5IkSfli/vz5ZGVl8fzzz1OrVi2WLFlCmTJlePXVV6OOJpVYLumUJEnS7zJnzhxatWrFKaecwowZM7jxxht57bXXPAmLVAg44ZMkSdIB27p1K7FYjNTUVL799ltWr15NZmYm11xzDampqVHHk7SPEz5JkiTl2erVqxkwYABpaWlkZmYC0LFjR5YtW0ZGRoZlTypknPBJkiTpN33wwQdkZmby4osvAnDhhRdy7rnnApCUlBRlNEm/wsInSZKkn5Wbm0ti4g8LwgYPHsw777xDRkYGN954I9WrV484naS8sPBJkiTpf/n+++8ZO3YsI0eO5LXXXqNu3bo8/PDDHHbYYZQvXz7qeJIOgIVPkiRJAKxYsYLhw4czduxYtm7dymmnnca2bdsASEtLizidpINh4ZMkSRJbt26lQYMG7N69m27dupGRkUGTJk2ijiXpd7LwSZIklUB79uzhxRdf5B//+AejR4+mfPnyjB8/nmbNmlG1atWo40nKJxY+SZKkEmTTpk089thjPPzww6xZs4a6deuyceNGKlWqRJcuXaKOJymfeR0+SZKkEmLOnDmkpaUxcOBA6taty4wZM1iyZAmVKlWKOpqkOHHCJ0mSVEzFYjHmzJlDdnY2bdq0oUmTJlx66aVcd911NG7cOOp4kgqAhU+SJKmY2b17N88//zxZWVksWLCAli1b0qZNGw499FDGjBkTdTxJBSRP/WcAACAASURBVMglnSo2Jn6wmm5j5rFo3Zaoo0iSFJkJEyZQs2ZNLr/8cnbu3MmYMWN4/fXXo44lKSJO+FRsTFu4lkXrtpBeJZWOjT27mCSp5AjDkCOPPJKKFStSunRpjj/+eMaOHUubNm1ITPTn+1JJ5juAipX0KqlM6tWc7k2rRx1FkqS4isVivP3225x77rnUq1ePUaNGAdCtWzdef/112rZta9mTZOGTJEkqasaPH0/jxo1p3bo1//rXv7j99tvp2bNn1LEkFUIu6ZQkSSoCtm3bRrly5QCYNGkSubm5jB07lu7du5OSkhJxOkmFlYVPkiSpEFu0aBFDhw5l4sSJfPrpp9SsWZNnnnmGChUqkJCQEHU8SYWchU+SJKmQicVivPHGG2RmZjJr1ixSUlLo0aMHpUr98K3bYYcdFnFCSUWFhU+SJKmQ2bBhA+eeey6VK1fm7rvvplevXhx++OFRx5JUBFn4JEmSIrZhwwZGjRrFkiVLmDRpEkcffTRvv/02p5xyCsnJyVHHk1SEeZZOSZKkiHz66adcffXVVK9enTvvvJOdO3eya9cuAFq2bGnZk/S7OeGTJEmKwOTJk7nooosoU6YM1157LX379uW4446LOpakYsbCJ0mSVAB27NjB008/zdFHH03Hjh0555xzuO++++jZsyeVKlWKOp6kYsolnZIkSXH09ddfc9ttt5GWlkbv3r154YUXAEhNTWXgwIGWPUlxZeGTJEmKk7vuuosaNWowePBgWrVqxZw5cxg/fnzUsSSVIBY+SZKkfJKbm8v06dPZvHkzAEEQ0Lt3b5YuXcpLL73Eaaed5sXSJRUoC58kSdLvtH37dkaOHEm9evXo2LHjT1O8iy66iOHDh1O7du2IE0oqqTxpiyRJ0kHKzc3ltttuY8yYMWzatIk//OEPPPfcc3Tp0iXqaJIEWPgkSZIO2MqVK6lRowaJiYksWLCA1q1bk5GRQfPmzV2yKalQsfBJkiTlQU5ODtOnTyczM5P333+fL7/8krS0NF555RVKlfJbKkmFk8fwSZIk/Ypt27YxfPhwjjvuOC644ALWrFnDgw8+yGGHHQZg2ZNUqPkOJUmS9DNycnJISkpi06ZN9O/fn2bNmvHAAw/QsWNHS56kIsN3K0mSpP28//77ZGVlsW3bNl555RXS0tIIw9AzbUoqklzSKUmSSry9e/cyefJkWrRoQfPmzZk1axYNGjQgNzcXwLInqchywidJkkq80aNH06dPH2rXrs3w4cO56qqrKFeuXNSxJOl3s/BJkqQS58svv2T48OG0bNmSCy+8kMsuu4y0tDTOO+88kpKSoo4nSfnGwidJkkqEWCzGe++9R2ZmJlOnTiUxMZFKlSoBULFiRTp16hRxQknKfxY+SZJUIlxxxRU8/fTTVKxYkYEDB3LDDTdQtWrVqGNJUlxZ+CRJUrG0adMmHn/8cXr37k358uXp3LkzzZs3p0ePHhx66KFRx5OkAmHhkyRJxcrSpUsZNmwY48aNY8eOHRx77LFcdNFFdO7cOepoklTgLHySJKlY2LVrFxdffDHTp0+nVKlSdO/enX79+tG4ceOoo0lSZLwOnyRJKrJ2797N3LlzAUhJSaFUqVLcdtttrFq1iieffNKyJ6nEc8KnQmHiB6uZtnDt79rGonVbSK+Smk+JJEmF2XfffceYMWMYMWIE3377LatXr+boo4/mhRdeiDqaJBUqTvhUKExbuJZF67b8rm2kV0mlY2PPtiZJxdmaNWu47rrrSEtL47bbbqNBgwZMnz6dI488MupoklQoOeFToZFeJZVJvZpHHUOSVMjEYjG2bNlChQoV2L17N+PHj//p+LwGDRpEHU+SCjULnyRJKpSys7N59tlnycrKIi0tjZdffplatWqxfv16ypcvH3U8SSoSXNIpSZIKlW+++YY777yTY489lquuuorc3Fy6dOny0+OWPUnKOyd8kiSpUBkzZgyDBg2iXbt29O/fn9atW5OQkBB1LEkqkpzwSZKkyMRiMV5//XXatm3L5MmTAbj++utZtGgRM2fO5KyzzrLsSdLv4IRPkiQVuF27djFhwgSGDh3K559/ztFHH82uXbsAqFSpEpUqVYo4oSQVDxY+SZJU4Nq0acM///lPGjduzFNPPUW3bt1ITk6OOpYkFTt5KnxBEKQCxwJfhmG4Pb6RJElScfPpp58yevRoHnzwQQ499FBuvfVWUlJSOP30012yKUlx9JuFLwiCC4Hb9j33+SAIYmEY3v0br0kERgGNgGzg2jAMl+33eDtg0L6bC4AbwjCMHdwfQZIkFUa5ubm89tprZGZm8tZbb1G2bFkuvvhiWrVqRdu2baOOJ0klQl5O2pIBNAO+Be4GOufhNZ2AlDAMmwP/Azz04wNBEJQHHgTODcOwGbASOPzAYkuSpMJs8+bNpKen06FDB5YsWcJ9993HV199RatWraKOJkklSl4KX24YhtlAbN8ULi9LOlsCrwGEYfg+cPJ+j7UAPgUeCoLgn8CGMAy/ObDYkiSpsPn666956aWXADjssMNo1aoVzzzzDCtWrGDgwIGeiEWSIpCXY/j+GQTBRKBaEASPAP/Kw2tSge/3u50TBEGpMAz38sM07wygMbBt3/bnhWH4xS9tLDs7m8WLF+fh0xasXbt2FcpcRdGOHTsA/Pvcj/uX4sn9S/lp0aJFjB8/npkzZ1K6dGnmzJlDUlISGRkZACxbtuw3tiAdGN/DFE/Fbf/6zcIXhuGtQRC0BT4GloRhOCMP290ClN/vduK+sgfwHfCvMAzXAwRBMIcfyt8vFr7k5GTq16+fh09bsBYvXlwocxVFZedsBvDvcz/uX4on9y/lh08++YR+/frxzjvvUK5cOa6//nr69OlD7dq13ccUV+5fiqfCun999NFHB/W6Xyx8QRAkAUnAc0A34G0gKQiCt8MwPPM3tjsXOI8fTvLSjB+WcP6UFWgQBMHhwGZ+OD7wsYNKL0mSCtS2bdvYvHkz1apVo0yZMqxYsYIhQ4ZwzTXXcNhhh0UdT5L0X35twnc1cCtwNBACCUAO8G4etvsScHYQBO/te91VQRD0B5aFYTg9CIJbgFn7nvt8GIafHewfQJIkxd+aNWt4+OGHefTRRznjjDOYMmUKxx13HF9++SWJiXk5JYAkKQq/WPjCMHwMeCwIgqvDMHziQDYahmEu0Pu/7l6y3+PP8cPkUJIkFWILFixgyJAhTJ48mdzcXLp06fLTsXmAZU+SCrm8nLRlzr6JXGl+mNYdE4Zhr/jGkiRJUcnJySEhIYHExESmTp3KK6+8Qp8+fbjxxhupUaNG1PEkSQcgLz+WG7/v95ZATaBy/OJIkqSobN26lWHDhlG3bl2mT58OwE033cRXX33FQw89ZNmTpCIoL4VvRxiGg4E1YRheCRwV30iSJKkgrVq1iptuuolq1arRr18/jjnmGCpWrAhAhQoVSE1NjTihJOlg5WVJZ0IQBEcD5YIgOBTwqqmSJBUTsViMNm3asHz5ci666CIyMjI45ZRToo4lSconeSl8dwCdgAnACv7/Ek9JklTE7N27lylTpvDUU0/xwgsvUKZMGZ544gmqV69OWlpa1PEkSfksL4XvD2EYDtn38ZHxDCNJkuLj+++/5/HHH2f48OGsXr2a2rVrs2LFCtLT0zn11FOjjidJipO8HMPXft9F2CVJUhG0cuVKqlWrxl/+8hdq1qzJ1KlTCcOQ9PT0qKNJkuIsLxO+w4GvgyBYAcSAWBiGLeIbS5IkHaxYLMbcuXMJw5BrrrmGY489ln79+tG5c2dOOumkqONJkgpQXgrfeXFPIUmSfrc9e/YwefJksrKymD9/PmlpafTo0YPSpUtz1113RR1PkhSB3yx8YRiuKoggkiTp4M2aNYtrrrmGtWvXctxxxzF69Oifyp4kqeTKy4RPkiQVQkuXLgWgbt26pKWlEQQBY8aMoV27diQm5uUwfUlScZfnrwZBEFSMZxBJkvTbYrEY77zzDueffz5BEPD3v/8dgPT0dN566y06dOhg2ZMk/eQ3J3xBEJwOjASSgiCYDKwKw3Bs3JOp0Jr4wWqmLVybr9tctG4L6VVS83WbklTcvPDCC9xzzz0sXLiQww8/nL/+9a9cf/31UceSJBViefkR4F1AK2A9cC/gV5YSbtrCtSxatyVft5leJZWOjavm6zYlqTj47rvvyM3NBeCjjz5i9+7dPPbYY6xevZo777yTo48+OuKEkqTCLC/H8OWGYbgxCIJYGIa7giDYGvdUKvTSq6QyqVfzqGNIUrG1ZMkShg4dyvjx45k8eTIdOnRg0KBB3HvvvSQkJEQdT5JUROSl8C0LgmAwUDkIgv8BPGunJElxEIvFeOutt8jMzOTVV18lOTmZyy67jLp16wKQkpIScUJJUlGTl8LXG7gWeBfYDvSMayJJkkqYWCxGQkICOTk5XHPNNezatYs77riD3r17c+SRR0YdT5JUhOWl8E0GHgPGhGEYi3MeSZJKjP/85z+MHj2al156iQ8++IDk5GRmzpxJ7dq1neZJkvJFXk7acg/QHvg4CILbgyCoHudMkiQVa59//jnXXnst1atX5/bbb6dq1ap89913ABx//PGWPUlSvvnNCV8YhvOB+fuuwzcaWAokxzuYJEnF0YIFC2jSpAllypThqquuom/fvtSrVy/qWJKkYiov1+E7DbgSOIUflnf+Jc6ZJEkqNnbu3MmECRPYunUr/fv358QTT2T06NF07dqVypUrRx1PklTM5eUYvn7Ao8C1HsMnSVLerF+/nlGjRjF69Gi+/fZbWrVqRUZGBgkJCfTu3TvqeJKkEuIXj+ELguDkfR8+CsSAs4MgaBMEQZsCSSZJUhE1duxYjj32WO6++25atGjB7Nmzeeedd7x+niSpwP3ahK81MB+4+L/ujwGvxy2RJElFTG5uLq+++io1a9YkPT2dk08+mZ49e9K3b9+frqEnSVIUfnHCF4bh/fs+nBuG4VU//gIWFkw0SZIKt+3btzN69GjS09M599xzGTVqFACNGjVixIgRlj1JUuR+ccIXBMElwPnAGUEQnLnv7kSgITC8ALJJklRoDR48mAcffJBNmzZx8sknM3HiRC688MKoY0mS9L/82pLO14B1QGVgzL77coHl8Q4lSVJh9O9//5uGDRuSkJDA5s2bOeOMM8jIyODUU0/1+DxJUqH0a4Xv0DAM3wmC4Ov/ur9cPANJklSY5OTk8PLLL5OZmcmcOXOYNWsWbdq04b777rPkSZIKvV8rfP33/RrzX/fHgDP/79MlSSo+srOzeeyxxxg6dCjLly+nevXqDBkyhKZNmwJY9iRJRcIvFr4wDPvv+/2MH+8LgiAtDMOvCiKYJElR2LVrFykpKSQkJDB48GCOPfZYBg8eTOfOnSlVKi+Xr5UkqfD4za9cQRD0AXYChwFXBUHw2o9lUJKk4uLDDz8kKyuL999/ny+++IJDDjmEBQsWcNRRR0UdTZKkg/aLl2XYzyXAU0A74HigcVwTSZJUQHJycnjxxRdp2bIlTZs2ZebMmXTp0oWdO3cCWPYkSUVeXtamxIAqwIYwDGNBEFSKcyZJkgrE7NmzufDCC6lZsyZDhw7l6quvpnz58lHHkiQp3+Sl8M0G5gCXBEGQBbwY30iSJMXHypUrGT58OBUrVuRvf/sbrVu35pVXXuGcc84hKSkp6niSJOW731zSGYbhbUANYClwcxiGd8U7lCRJ+WnevHl07dqV2rVr8/DDD7Nu3TrghzNttm/f3rInSSq2frPwBUHwR3642PobwNIgCM6OdyhJkvLL3//+d1q0aMGbb77JgAEDWLFiBaNGjYo6liRJBSIvSzrvBlqGYfh1EARVgSn8UP4kSSp0Nm/ezOOPP067du04/vjjueCCCzjqqKO44oorKFeuXNTxJEkqUHkpfDlhGH4NEIbh2iAIdsU5kyRJB2z58uUMHz6cJ554gm3btpGTk8Pxxx9P48aNadzYE0xLkkqmvBS+LUEQ3MgPJ25pBWyMbyRJkg5Mjx49mDBhAqVKleLiiy8mIyODE088MepYkiRFLi/X4bsMqM4PSzvTgKvjmkiSpN+wZ88epk+fTiwWA6BGjRrccsstrFy5kvHjx1v2JEna5zcnfGEYfh8EwXvAd8BnYRhuin8sSZL+r40bN/Loo48yYsQI1q5dyz//+U9atmzJnXfeGXU0SZIKpbycpfNxoBuwE+ix71p8kiQVmE2bNnHDDTeQlpbGLbfcQr169XjllVdo0aJF1NEkSSrU8nIMX8MwDJvu+3hYEATvxzOQJEkAsViM9evXU6VKFcqUKcPLL79Mt27d6NevHyeccELU8SRJKhLyUviWBUFQMwzDFUEQHAmsjnco/baJH6xm2sK1kXzuReu2kF4lNZLPLan4y87O5rnnnmPo0KFs3ryZpUuXkpKSwhdffEFycnLU8SRJKlLyctKWZsDiIAi+AFYCZwdBsC4Igq/jmky/atrCtSxatyWSz51eJZWOjatG8rklFV/ffvstd999NzVq1ODKK69k9+7d3HbbbT+dmMWyJ0nSgcvLSVtqF0QQHbj0KqlM6tU86hiS9LvEYjESEhJ47733+Nvf/sY555zDU089xdlnn01CQkLU8SRJKtLysqRTkqR8FYvFePPNN8nKyqJJkybcddddnHvuuSxatIj69etHHU+SpGIjL0s6JUnKF7t27WLcuHE0atSINm3asGDBAg4//HAAEhMTLXuSJOWzPE34giBIBY4FvgzDcHt8I0mSiqvrr7+ecePG0bBhQ8aNG8cll1zisXmSJMVRXq7DdyHwD2Ai0D8Igr/GPZUkqVj47LPPuOaaa1iyZAkAGRkZvPnmm3zyySdceeWVlj1JkuIsL0s6M/jhTJ3fAncDneOaSJJUpMViMV577TXatGlDw4YNefbZZ1mwYAEADRs2pHXr1p6MRZKkApKXwpcbhmE2EAvDMAa4pFOS9LNyc3P5wx/+QLt27fjss8+49957+eqrr+jevXvU0SRJKpHyUvj+GQTBs0C1IAgeAf4V50ySpCJk3bp1jBw5klgsRmJiIhdddBFPP/00K1eu5JZbbqFy5cpRR5QkqcTKy3X4bg2CoC2wAFgchuHL8Y8lSSrsPvnkE7Kyspg4cSJ79+7lzDPPpH79+gwYMCDqaJIkaZ+8nLSlB3AksAGotO+2JKmEWrVqFa1bt6Zx48a88MIL9OrViy+++MJLKkiSVAjl5bIMP34FTwAaAxuB8XFLJEkqdLZv386KFSto0KABRxxxBBs3buT++++nZ8+eVKxYMep4kiTpF+RlSectP34cBEEC4JJOSSoh1q5dy4gRIxgzZgyVK1cmDEPKli3LggULPNOmJElFwG8WviAIDtnvZhWgZvziSJIKg88//5zBgwczadIkcnNz6dy5MxkZGT+VPMueJElFQ16WdIZAjB+WdO4EHoxrIklSJHJycti9ezdlypRhyZIlTJs2jT//+c/06dOHmjX9WZ8kSUVRXgrf38IwnHAgGw2CIBEYBTQCsoFrwzBc9jPPeQWYFobhIweyfUlS/tm2bRvjxo1j2LBhXH755QwaNIhOnTqxZs0aKlSoEHU8SZL0O+TlOnw9D2K7nYCUMAybA/8DPPQzz7kbqHQQ25Yk5YPVq1czYMAAqlWrRp8+fTjiiCNo0qQJAElJSZY9SZKKgbxM+JKDIPiYH5Z25gKEYdj9N17TEnht33PfD4Lg5P0fDILgwn3bevWAE0uS8kXfvn2ZMWMGXbp0ISMjg2bNmkUdSZIk5bO8FL6BB7HdVOD7/W7nBEFQKgzDvUEQNAC6AxcCf8/LxrKzs1m8ePFBxIivXbt2RZZrx44dAIXy70X5I8r9S8XP3r17eeutt3j66ae55557OOqoo/jTn/7EDTfcQNWqVQHfT5S/fA9TPLl/KZ6K2/71i4UvCIJJYRh2C8PwHwex3S1A+f1uJ4ZhuHffxz2AqsDbQA1gdxAEK8MwfO2XNpacnFwoL+i7ePHiyHKVnbMZoFD+vSh/RLl/qfjYsmULY8eOZfjw4axcuZKaNWuSkpJCSkoK7dq1izqeijHfwxRP7l+Kp8K6f3300UcH9bpfm/AdcXBRAJgLnAc8HwRBM+DTHx8Iw/DmHz8OguB2YP2vlT1J0sHZtWsXderU4ZtvvqFly5ZkZmZy/vnnk5SUVKx+cilJkn7ZrxW+2kEQ3PtzD4RheOtvbPcl4OwgCN7jh8s5XBUEQX9gWRiG0w8uqiTp18RiMebNm8err77KXXfdRUpKCvfccw8nnngiJ5988m9vQJIkFTu/Vvh28MOJWg5YGIa5QO//unvJzzzv9oPZviTp/9u7dy8vvvgimZmZfPjhhxx22GFcf/31VKlShZ49D+ZEy5Ikqbj4tcK3PgzDpwosiSTpgH388cd07NiRr776ijp16jBixAiuuOIKypUrF3U0SZJUCPxa4Tu4owIlSXG1fPlyNmzYQIsWLahbty6NGjVi5MiRdOjQgcTEvFxeVZIklRS/WPjCMPxLQQaRJP2yWCzGu+++S2ZmJtOmTeOEE05g4cKFlCtXjhkzZkQdT5IkFVL+KFiSCrnXX3+dU045hVatWjFnzhxuvfVWZs6cGXUsSZJUBOTlwuuSpAK2ceNGSpUqRWpqKt999x3bt2/nkUce4fLLL6ds2bJRx5MkSUWEEz5JKkS++OILbrjhBtLS0hg5ciQAF110EZ9//jm9evWy7EmSpAPihE+SCoHZs2eTmZnJyy+/zCGHHMKll17KeeedB0BSUlLE6SRJUlFl4ZOkiOTk5PxU5h544AE++ugjBg0axHXXXcdRRx0VcTpJklQcWPgkqYB9++23PPLII4wZM4Z3332XY489lscee4zDDz+clJSUqONJkqRixMInSQVk8eLFDB06lPHjx7Nr1y7atm3Ljh07AKhWrVrE6SRJUnFk4ZOkArBx40YaN25MYmIil19+Of369SM9PT3qWJIkqZiz8ElSHOzatYtnnnmG+fPnM3r0aCpVqsSkSZM49dRTOeKII6KOJ0mSSggLnyTlow0bNjB69GhGjRrFN998wwknnMDWrVspX748nTp1ijqeJEkqYSx8kpRPXn/9dc4//3yys7M599xzycjI4IwzziAhISHqaJIkqYSy8EnSQcrNzWXWrFmUKlWKs88+m6ZNm/KnP/2JG264gSAIoo4nSZJEYtQBJKmo2blzJ48++ijHH3887du3Z8iQIQBUqFCB4cOHW/YkSVKhYeGTpAPw6KOPkpaWRq9evShbtixPP/00M2bMiDqWJEnSz3JJpyT9hoULF1KzZk0qVKhA2bJladmyJf379+e0007z+DxJklSoOeGTpJ+Rm5vLjBkzOPPMMznxxBN5/PHHAbjsssuYOnUqrVq1suxJkqRCz8InSfuJxWKMGjWKevXqcf7557N06VIeeOABrr766qijSZIkHTCXdEoS8P3331OhQgUSEhKYMmUKFStW5Nlnn6VLly6ULl066niSJEkHxcInqUSbP38+WVlZvPTSSyxdupSqVasyZcoUypcv75JNSZJU5Fn4JJU4OTk5TJ8+naysLP75z39Svnx5evXqRVJSEgCpqakRJ5QkScofFj5JJc7XX39N165dqVatGpmZmVxzzTWWPEmSVCxZ+CQVe6tXr+bhhx/mq6++4rnnniMtLY13332Xk08+mVKlfBuUJEnFl2fplFRsffDBB3Tr1o1atWqRlZUFwJ49ewBo1qyZZU+SJBV7frcjqVh68sknueqqq6hQoQIZGRnceOONVK9ePepYkiRJBcrCJ6lY+P777xk7dix169blvPPOo2PHjgwfPpwrr7yS8uXLRx1PkiQpEi7plFSkrVixgoyMDNLS0rjpppt49dVXAahYsSI33nijZU+SJJVoTvgkFVkDBw5kyJAhJCYm0q1bNzIyMmjSpEnUsSRJkgoNJ3ySiow9e/YwadIktm7dCkDjxo25+eabWblyJRMmTLDsSZIk/RcLn6RCb9OmTTzwwAPUqlWLiy++mEmTJgFwySWXMHjwYKpWrRpxQkmSpMLJJZ2SCq09e/bQv39/xo0bx/bt2znjjDMYPXo07du3jzqaJElSkeCET1KhEovF+OKLLwAoXbo0S5Ys4cILL+Tjjz/m7bff5txzzyUx0bcuSZKkvHDCJ6lQ2L17N88//zxZWVl89tlnrFq1iqOPPppZs2ZZ8CRJkg6S30VJitTmzZsZPHgwNWvW5PLLL2fnzp08/PDDVKhQAcCyJ0mS9Ds44ZMUiT179lC6dGk2btzIX//6V1q3bs3YsWNp06aNJU+SJCmfWPgK0MQPVjNt4dp82daidVtIr5KaL9uSCkosFmP27NlkZmaSlJTEtGnTqFWrFitXriQtLS3qeJIkScWOP0YvQNMWrmXRui35sq30Kql0bOyp6FU0ZGdn8+STT9K4cWNat27Nhx9+SJMmTYjFYgCWPUmSpDhxwlfA0qukMqlX86hjSAVq2LBhDBw4kAYNGjB27Fi6d+9OSkpK1LEkSZKKPQufpHy3aNEihg4dSvv27enUqRNXX301J510Eq1btyYhISHqeJIkSSWGhU9SvojFYrzxxhtkZmYya9YsUlJSqFevHgCHH344Z511VsQJJUmSSh4Ln6R8ccEFFzB16lSOPvpo7r77bnr16sXhhx8edSxJkqQSzcIn6aBs2LCBxx57jP79+1O2bFkuu+wyOnfuTLdu3UhOTo46niRJkrDwSTpAn376KVlZWTzzzDPs3r2bE088kQ4dOtClS5eoo0mSJOm/WPgk5cm2bdvo3Lkzb775JmXLluXaa6+lb9++HHfccVFHkyRJ0i+w8En6RTt27GD+/Pm0atWKcuXKUaFCBe677z569uxJpUqVoo4nSZKk32Dhk/R/fP3114wcOZJHHnmEHTt2sGbNGipXrswLL7wQdTRJ0cEGYgAAF0JJREFUkiQdgMSoA0gqPL788kt69OhBjRo1GDx4MK1ateL11193midJklREOeGTSrjc3Fw2b95MpUqV2LNnD9OmTeO6666jT58+1K5dO+p4kiRJ+h0sfFIJtX37dp588kmGDRtGw4YNefHFFwmCgHXr1lG2bNmo40mSJCkfuKRTKmHWrFnDwIEDqVatGn/+85+pWLEiF1988U+PW/YkSZKKDyd8UgkRi8VISEhgzJgxDBkyhAsuuICMjAyaN29OQkJC1PEkSZIUB074pGIsJyeHKVOmcNpppzF9+nQA+vbty7Jly5g8eTItWrSw7EmSJBVjFj6pGNq6dSvDhg2jbt26dOnShTVr1rB3714ADj/8cGrWrBlxQkmSJBUEl3RKxdDpp5/Oxx9/TIsWLXjwwQfp2LEjpUr5312SJKmk8TtAqRh4//33eeyxxxg5ciQpKSnce++9VKxYkaZNm0YdTZIkSRFySadURO3du5fnn3+e5s2b07x5c1588UU+/fRTANq2bWvZkyRJkoVPKorWr19P7dq16datG9988w3Dhw9nzZo1nHLKKVFHkyRJUiHikk6piPjyyy/5+OOP6dKlC0cddRTt2rWjbdu2nHfeeSQlJUUdT5IkSYVQXApfEASJwCigEZANXBuG4bL9Hs8AfrzS88wwDO+IRw6pqIvFYsydO5esrCymTp1KamoqHTp0ICUlhUceeSTqeJIkSSrk4rWksxOQEoZhc+B/gId+fCAIglrApUALoDnQJgiCE+KUQyqyPvnkE5o2bcppp53G7NmzGThwIJ999hkpKSlRR5MkSVIREa8lnS2B1wDCMHw/CIKT93vsK6BtGIY5AEEQlAZ2xSmHVKRs2rSJbdu2kZaWRtmyZfn+++8ZNWoUPXr04NBDD406niRJkoqYeBW+VOD7/W7nBEFQKgzDvWEY7gG+DYIgAXgQ+DgMwy9+bWPZ2dksXrw4TlEP3q5duw4o144dOwAK5Z9F0Vq5ciUTJkzgpZde4owzzmDIkCGkpaXx0ksvkZCQwOrVq6OOqGLmQN+/pAPlPqZ4cv9SPBW3/StehW8LUH6/24lhGO798UYQBCnAE8BW4Prf2lhycjL169fP95C/1+LFiw8oV9k5mwEK5Z9F0Zg7dy4PPvgg06dPp1SpUnTv3p2MjAzq169/wPuXdCDcvxRv7mOKJ/cvxVNh3b8++uijg3pdvArfXOA84PkgCJoBn/74wL7J3jTg7TAM74/T55cKrd27d1OqVCkSExOZMWMG7777LrfddhvXX389VapUiTqeJEmSipF4Fb6XgLODIHgPSACuCoKgP7AMSAJOB5KDIGi37/m3hGE4L05ZpELhu+++Y8yYMYwYMYLHH3+c9u3bc8sttzBo0CDKlCkTdTxJkiQVQ3EpfGEY5gK9/+vuJft97GkGVWKEYcjQoUN56qmn2LlzJ23atKFy5coAVKhQIeJ0kiRJKs688HocTfxgNdMWrv3p9qJ1W0ivkhphIhW03NxczjnnHNavX89ll11Gv379aNCgQdSxJEmSVEJY+OJo2sK1/6vkpVdJpWPjqhGnUjxlZ2fz7LPPMnHiRGbMmEFycjITJ06kTp06HHnkkVHHkyRJUglj4Yuz9CqpTOrVPOoYirNvvvmGRx55hJEjR7JhwwYaNGjAmjVrqF27Ni1atIg6niRJkkooC5/0Oy1ZsoQTTzyRXbt20b59ezIyMmjdujUJCQlRR5MkSVIJZ+GTDlAsFuP111/nq6++4tprryUIAgYOHEi3bt0K5TVbJEmSVHIlRh1AKip27tzJ448/TsOGDWnbti0PPvggubm5JCQkcPvtt1v2JEmSVOhY+KQ8mDp1Ksceeyw9e/akdOnSPPXUU/z73/8mMdH/QpIkSSq8XNIp/YJ///vflC1bljp16lCjRg2aNWtG//79Of300z0+T5IkSUWC4wlpP7m5ucycOZOzzjqLRo0ace+99wLQuHFjpk+fzh//+EfLniRJkooMC5+0z/jx40lPT6dDhw4sWbKE++67jyFDhkQdS5IkSTpoLulUibZ+/XqOOuooEhISWLhwIeXKleOZZ56ha9eulC5dOup4kiRJ0u/ihE8l0scff0yPHj2oXr06b731FgCDBw/mX//6F927d7fsSZIkqVhwwqcSIzc3l5dffpmsrCzeeecdypUrx3XXXUfdunUBSE5OjjihJEmSlL8sfCr2YrEYCQkJ7N27l969e1O6dGmGDBnCNddcw2GHHRZ1PEmSJCluLHwqttasWcPDDz/MrFmzmD9/Pocccghvv/02derUoVQpd31JkiQVfx7Dp2Lnx+PwatasyZAhQ6hbty6bNm0CoF69epY9SZIklRh+56tiZe7cubRs2ZLU1FT69OnDjTfeSI0aNaKOJUmSJEXCwqcibevWrTzxxBPk5uaSkZFB8+bNeeyxx7joootITU2NOp4kSZIUKZd0qkhatWoVN910E9WqVaNfv368/fbbACQmJnLttdda9iRJkiQsfCqChg8fTq1atRg2bBjt27fngw8+YMaMGVHHkiRJkgodC58Kvb179/L8888ThiEALVq04C9/+QsrVqzg2Wef5Q9/+EPECSVJkqTCycKnQuv777/noYceonbt2nTr1o2xY8cCcPLJJ3P//feTlpYWcUJJkiSpcPOkLSqUbrvtNoYPH862bds4/fTTGT58OOeee27UsSRJkqQixQmfCoVYLMb8+fOJxWIA7Ny5k06dOvHRRx/xzjvv0LFjR5KSkiJOKUmSJBUtTvgUqT179vDCCy+QmZnJ/Pnzeeeddzj99NN56KGHSEhIiDqeJEmSVKQ54VMkduzYwf3330+tWrXo3r07W7ZsYfTo0ZxyyikAlj1JkiQpHzjhU4HasWMHZcuWJTExkczMTBo2bMgjjzxCu3btSEz05w+SJElSfrLwKe5isRj/+Mc/yMzMZNGiRYRhSEpKCosWLaJy5cpRx5MkSZKKLUcqipvdu3fz9NNPc9JJJ3HGGWcwb948unfvTnZ2NoBlT5IkSYozJ3yKm1mzZtGjRw/S09N59NFHueyyyyhTpkzUsSRJkqQSw8J3kCZ+sJpn3/uasnM2/+JzFq3bQnqV1AJMFa0lS5YwdOhQqlevzq233kr79u158803OfPMMz0JiyRJkhQBl3QepGkL1/Llxt2/+pz0Kql0bFy1gBJFIxaL8eabb9KhQwfq16/Pk08+yebNP5TgpKQkWrdubdmTJEmSIuKE73eoVekQJvVqHnWMSN10001kZWVx5JFHcscdd9C7d2+OPPLIqGNJkiRJwsKnA/TNN98wevRounXrRhAEXHrppTRs2JBLLrmElJSUqONJkiRJ2o+FT3ny+eefk5WVxYQJE8jOzqZSpUoEQUCTJk1o0qRJ1PEkSZIk/QwLn35VLBbjggsuYOrUqZQpU4Yrr7ySfv36Ua9evaijSZIkSfoNFj79Hzt37mTmzJl06dKFhIQEGjRowCmnnEKvXr28dp4kSZJUhFj49JP169czatQoRo8ezbfffsv8+fNp0qQJd911V9TRJEmSJB0EL8sg/vOf/3DllVdy7LHHcvfdd9OiRQtmz57NSSedFHU0SZIkSb+DE74SKjc3l7Vr15KWlka5cuWYPXs2PXv2pG/fvtStWzfqeJIkSZLygYWvhNmxYwfjx49n6NCh5ObmsmTJEsqWLcvy5cspVcrdQZIkSSpO/A6/hPj6668ZMWIEY8aMYePGjZx88sn079+fWCwGYNmTJEmSiiG/yy/mcnNzSUxM5L333uP++++nU6dOZGRkcOqpp5KQkBB1PEmSJElx5ElbiqGcnBymTZvGH//4R+6++24AOnXqxNKlS3nxxRdp2bKlZU+SJEkqASx8xci2bdsYMWIEQRDQqVMnVqxYwTHHHAP8sGSzVq1aESeUJEmSVJBc0lmM9OzZk+eee45mzZoxePBgOnfu7LF5kiRJUgnmhK8I+/DDD+nevTvLly8H4JZbbmHevHnMmzePrl27WvYkSZKkEs7CV8Tk5OT8dBxe06ZNeeWVV/jss88AOOGEE2jWrFnECSVJkiQVFo6AipC9e/fSsGFDlixZQs2aNRk6dChXX3015cuXjzqaJEmSpELIwlfIrVy5khkzZnDjjTdSqlQprr76aurUqcP5559PUlJS1PEkSZIkFWIWvkJq3rx5ZGZmMmXKFBITEznvvPOoUaMGAwYMiDqaJEmSpCLCY/gKmaVLl9KsWTNatGjBm2++yYABA1ixYgU1atSIOpokSZKkIsYJXyGwefNmVq9ezQknnECVKlXIzc1lxIgRXHHFFZQrVy7qeJIkSZKKKAtfhJYvX87w4cN54oknqF69Op999hnlypXjww8/jDqaJEmSpGLAJZ0R+Oijj+jcuTN169Zl9OjRdO7cmQkTJvD/2rv3GLnKMo7j361d26qlgBgqqG0F+qQK1AQp5VLkDiUqjaERqMGSIKgkUIgBKlSjaQUvIAuKlwo2CtpoSLVeaCVWbCkWtKBQaR+sKBBu4Vpu7dpt6x/nkEzW7nRAZmbn8P0km50z7zlnfid5MnOefc/Z6erqanc0SZIkSRXiDF+LbN68mb6+PkaMGEFmsnz5cmbPns0555zDHnvs0e54kiRJkirIGb4me+aZZ7j88ssZN24cPT09AEyfPp2HH36YefPm2exJkiRJahpn+Jrk/vvvp6enhwULFvDyyy9z9NFHM2nSJAC6u7vp7u5uc0JJkiRJVWfD1yTnnXcey5YtY8aMGcyaNYv999+/3ZEkSZIkvcE0peGLiCHAtcBEoBc4MzPX14x/Cjgb6APmZuavm5GjVXp7e1m4cCHXXHMNN910E2PGjKGnp4dRo0ax++67tzueJEmSpDeoZt3DNw0YnpkHAxcDV7wyEBGjgXOBQ4HjgcsiYliTcjRVX18fc+fOZezYscycOZONGzfy2GOPATB+/HibPUmSJElt1ayG7zBgCUBmrgI+WDM2CViZmb2ZuQFYD3Tc9Y5btmzhnnvuYc6cOUycOJGlS5eyZs0aJk+e3O5okiRJkgQ07x6+nYANNctbImJoZvZtZ+wFYFS9nfX29rJ27drXP+X/4UPveTPDHx3GxxcvZu+99wZg3bp1bU6lKtm0adOgq3tVh/WlZrPG1EzWl5qpavXVrIbveWBkzfKQstnb3thI4Ll6Oxs2bBgTJkx4fRP+nyZMgGP2Gjnocqk61q5da32paawvNZs1pmayvtRMg7W+Vq9e/Zq2a9YlnSuBEwEiYjJwb83YncCUiBgeEaOACcCaJuWQJEmSpDesZs3wLQKOjYjbgS7gjIi4AFifmYsj4mpgBUXDeUlmbmpSDkmSJEl6w2pKw5eZW4FP93t6Xc34fGB+M15bkiRJklRo1iWdkiRJkqQ2s+GTJEmSpIqy4ZMkSZKkirLhkyRJkqSKsuGTJEmSpIqy4ZMkSZKkirLhkyRJkqSKsuGTJEmSpIqy4ZMkSZKkirLhkyRJkqSKsuGTJEmSpIqy4ZMkSZKkiuratm1buzPs0OrVq58EHmx3DkmSJElqkzEHHHDAO17tRh3R8EmSJEmSXj0v6ZQkSZKkirLhkyRJkqSKsuGTJEmSpIqy4ZMkSZKkirLhkyRJkqSKsuGTJEmSpIoa2u4AnSAihgDXAhOBXuDMzFxfM/4p4GygD5ibmb9uS1B1pAbq63zglHLxt5n5pdanVKfaUX3VrPMb4JeZ+d3Wp1SnauD9ayrwxXLxLuCczPT7oNSQBurrc8CpwFbgK5m5qC1B1dEi4iDgq5l5RL/nPwJ8geL8/vrMnN+GeK8LZ/gaMw0YnpkHAxcDV7wyEBGjgXOBQ4HjgcsiYlhbUqpT1auv9wIzgEOAg4HjImL/tqRUpxqwvmrMBXZtaSpVRb33r5HA14EPZ+Zk4N/Abu0IqY5Vr752pjj/Ohg4DriqLQnV0SLiQuAHwPB+z3cD36SorQ8BZ5Xn/B3Jhq8xhwFLADJzFfDBmrFJwMrM7M3MDcB6wBNyvRr16uth4ITM3JKZW4FuYFPrI6qD1asvIuJkir+O39z6aKqAevV1CHAvcEVErACeyMwnWx9RHaxefb0EPAi8tfzZ2vJ0qoJ/Ah/bzvMTgPWZ+Wxm/ge4DZjS0mSvIxu+xuwEbKhZ3hIRQwcYewEY1apgqoQB6yszN2fmUxHRFRHfAO7OzPvbklKdasD6ioh9gdMoLlmRXot6n4+7AUcCFwFTgVkRMb7F+dTZ6tUXFH8UvY/icuGrWxlM1ZCZNwGbtzNUqfN7G77GPA+MrFkekpl9A4yNBJ5rVTBVQr36IiKGAzeW63y2xdnU+erV1+nAnsAyYCZwQUSc0Np46nD16utp4M+Z+XhmvggsBz7Q6oDqaPXqayrwTmAc8B5gWkRManE+VVelzu9t+BqzEjgRICImU1yi8oo7gSkRMTwiRlFMAa9pfUR1sAHrKyK6gF8Cf8vMszNzS3siqoMNWF+ZeWFmHlTeqL4AuDIzl7QjpDpWvc/H1cC+EbFbOSszmWI2RmpUvfp6FtgI9GbmJoqT8Z1bnlBVtRbYJyJ2jYg3A4cDf2pzptfM/9LZmEXAsRFxO9AFnBERF1Bc27s4Iq4GVlA00JeUbzxSowasL+BNFDcLDyv/2x3A7Mzs2DcdtVzd96/2RlMF7OjzcTawtFz3Z5npH0T1auyovo4BVkXEVop7rG5pY1ZVQEScBrwtM79f1tpSivP76zPzkfame+26tm3zvyNLkiRJUhV5SackSZIkVZQNnyRJkiRVlA2fJEmSJFWUDZ8kSZIkVZQNnyRJkiRVlF/LIElqu4gYC9wD3FXz9LLM/PIA6y8AFrbrewMj4irgSuBF4ITM/ElEXEyR+c4mvu5ZwA8zc3OzXkOSVC02fJKkweK+8kvgB73MnAUQEUcAHwV+kpmXt+ClPw/8CLDhkyQ1xIZPkjRoRcSbgO8B7wbeDtycmXNqxscDCygaoD7g9Mx8JCIuAw6nuHXhysz8eb/9PgDcAewFrAHOBHYCbih/DwUuzcxlETEPOKrc108z86qIuBX4NHAJMLGceTsEWAicBfRk5h8j4kDgUuBk4LvAPuV+Ls3MW2vyjAV+BTwN/LbM9sVy+C3A6cAUYHT5GtN2dIySJIH38EmSBo/3RcStNT97UjR6qzLzeOAw4DP9tjkWWA0cA8wDdomIqcC4zDwUOBK4JCJ27rfdu4A5mTkJeBswjaIxuyUzDwemA9dFxBCKZus0iuZqY7/9zKO4jPP7Nc/NBz5ZPp5ZLp8JPFXu+yTg29s5/tHAcZn5NeD9wCcy8yhgMTA9M68DHgdOafAYJUlyhk+SNGj8zyWdEbETcGBEHAk8Dwzrt811wEXAEmADxSWP+wEHlLNwAN3AGOC5mu0eysz15ePbgQAmADcClLOEzwPvAE4BLqNoyG5u4DiWAl+PiF0pZuXOBa4BpkTEQeU6QyPi7Zn5dM12/8rM/5SPHwGujogXgT2Blf1eo5FjlCTJGT5J0qA2E3guM2cAVwBviYiumvGTgBWZeTTwc4rmbx3wh7J5PAr4GfBAv/3uGRGjy8eHAn8H1lI0aJSzi7tQNFDTgVPLfc2MiDE1+9lKv8/SzNxaZvkO8IvM3FJm+mmZaWo5/my/TFtrHv8AOCMzZwKPAl016wxp8BglSXKGT5I0qP0eWBgRU4CXgH8Ae9SM/wW4ISL6KJqh84G7gSMiYgXF5ZqLMvOFfvvtBb4VEe8GVlHcP3cbcH1EnAyMAM7KzN6IeAb4K0WD9jvgoZr9/BPYLyJm9dv/9RQN2D7l8veA+RHxR4p7BK8tG8OB/Bi4IyKeBZ6oOeYVFPf4HdnAMUqSRNe2bdvanUGSpJaKiMczc/SO15QkqbN5SackSZIkVZQzfJIkSZJUUc7wSZIkSVJF2fBJkiRJUkXZ8EmSJElSRdnwSZIkSVJF2fBJkiRJUkX9F2db+HTaOj1uAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 1080x1080 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "y_score = proba_sm[1]\n",
    "y_test = y_t[1]\n",
    "precision, recall, thresholds = precision_recall_curve(y_test, y_score)\n",
    "from sklearn.metrics import average_precision_score\n",
    "average_precision = average_precision_score(y_test, y_score)\n",
    "\n",
    "print('Average precision-recall score: {0:0.2f}'.format(\n",
    "      average_precision))\n",
    "from sklearn.utils.fixes import signature\n",
    "step_kwargs = ({'step': 'post'}\n",
    "               if 'step' in signature(plt.fill_between).parameters\n",
    "               else {})\n",
    "plt.figure(figsize=(15,15))\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.step(recall, precision, color='b', alpha=0.2,\n",
    "         where='post')\n",
    "plt.fill_between(recall, precision, alpha=0.2, color='b', **step_kwargs)\n",
    "\n",
    "plt.xlabel('Recall')\n",
    "plt.ylabel('Precision')\n",
    "plt.ylim([0.0, 1.05])\n",
    "plt.xlim([0.0, 1.0])\n",
    "plt.title('2-class Precision-Recall curve: AP={0:0.2f}'.format(\n",
    "          average_precision))\n",
    "plt.subplot(2,1,2)\n",
    "fpr, tpr, _ = roc_curve(y_test, y_score)\n",
    "auc_score = roc_auc_score(y_test, y_score)\n",
    "\n",
    "plt.plot([0, 1], [0, 1], 'k--')\n",
    "plt.plot(fpr, tpr)\n",
    "plt.xlabel('False positive rate')\n",
    "plt.ylabel('True positive rate')\n",
    "plt.title('ROC curve: AUC Score = {0:0.2f}'.format(\n",
    "          auc_score))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### SGD Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf = SGDClassifier(loss = 'log')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "AUC_LR_sm = []\n",
    "AUC_LR = []\n",
    "proba_sm = []\n",
    "proba = []\n",
    "y_t = []\n",
    "y = df['crisisST'].values\n",
    "X = df.drop(['crisisST'], axis=1).values\n",
    "scaler = StandardScaler()\n",
    "X  = scaler.fit_transform(X)\n",
    "sm = SMOTE(0.5,random_state=42)\n",
    "tscv = TimeSeriesSplit(n_splits=n)\n",
    "for train_index, test_index in tscv.split(X):\n",
    "    X_train, X_test = X[train_index], X[test_index]\n",
    "    y_train, y_test = y[train_index], y[test_index]\n",
    "    y_t.append(y_test)\n",
    "    X_train_sm, y_train_sm = sm.fit_resample(X_train, y_train)\n",
    "    clf.fit(X_train_sm, y_train_sm)\n",
    "    y_proba1 = clf.predict_proba(X_test)\n",
    "    clf.fit(X_train, y_train)\n",
    "    y_proba = clf.predict_proba(X_test)\n",
    "    AUC_LR.append(roc_auc_score(y_test, y_proba[:,1]))\n",
    "    proba.append(list(y_proba[:,1]))\n",
    "    AUC_LR_sm.append(roc_auc_score(y_test, y_proba1[:,1]))\n",
    "    proba_sm.append(list(y_proba1[:,1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.42467532467532465\n",
      "Confusion_Matrix 1\n",
      "[[345   5]\n",
      " [ 22   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.7942583732057418\n",
      "Confusion_Matrix 2\n",
      "[[353   8]\n",
      " [ 10   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.28648648648648645\n",
      "Confusion_Matrix 3\n",
      "[[370   0]\n",
      " [  2   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6892655367231638\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 18   0]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.345974025974026\n",
      "Confusion_Matrix 1\n",
      "[[312  38]\n",
      " [ 21   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6043817678166707\n",
      "Confusion_Matrix 2\n",
      "[[235 126]\n",
      " [  6   5]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.49729729729729727\n",
      "Confusion_Matrix 3\n",
      "[[236 134]\n",
      " [  1   1]]\n",
      "--------------------------------------------------------------------------------\n",
      "AUC Score: 0.6371625863151287\n",
      "Confusion_Matrix 4\n",
      "[[354   0]\n",
      " [ 17   1]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(None, None)"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def conf_mat(prob, AUC):\n",
    "    for i in range(n):\n",
    "        y_pred = []\n",
    "        for j in range(len(prob[i])):\n",
    "            if prob[i][j]>0.5:\n",
    "                y_pred.append(1)\n",
    "            else: \n",
    "                y_pred.append(0)\n",
    "        print( \"-\"*80)\n",
    "        print('AUC Score:', AUC[i])\n",
    "        print('Confusion_Matrix', i+1)\n",
    "        print(confusion_matrix(y_t[i],y_pred))\n",
    "conf_mat(proba, AUC_LR), conf_mat(proba_sm, AUC_LR_sm)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
